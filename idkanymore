<!DOCTYPE html>
<!-- To Infinity and Beyond! ** Might be useful for colours instead-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SS</title>

  <style>
/* Container for the grid */
#grid {
  border-collapse: collapse;
  margin: 20px auto;
}

table {
border-collapse: collapse;
}

/* Each cell */
td.cell {
  width: 30px;
  height: 30px;
  background-color: lightgray;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

/* Thicker borders */
td.cell {
  border-right: 1px solid #555;
  border-bottom: 1px solid #555;
}

td.cell.sector-left {
border-left: 3px solid #aaa;
}

td.cell.sector-top {
border-top: 3px solid #aaa;
}

/* Revealed cell */
td.cell.revealed {
  background-color: lightblue;
  cursor: default;
}

/* Mine cell */
td.cell.mine {
  background-color: red;
  color: white;
}

/* Flagged cell */
td.cell.flagged {
  background-color: orange;
  color: white;
}

  /* Hint cell */
.hint {
  outline: 3px solid yellow;
  animation: pulse 0.4s infinite alternate;
}

@keyframes pulse {
  from { transform: scale(1); }
  to { transform: scale(1.1); }
}
    
</style>

</head>
<body>

<h1>SS</h1>

<table id="grid">
  <!-- JS will generate rows and cells -->
</table>


<div> 
  <p id="feedback"></p>
</div>

<div> 
  <button id="hintBtn">Hint</button>
  <button id="resetBtn">Start a new game</button>
</div>


<script>

// ==== GLOBALs + CONSTANTS ====

let size = 8; // start with 10, easier to adjust later
let totalMines = Math.floor(Math.random() * 16 + 10)
let firstClick = true;
let board = new Map();
let grid = [];
let gameOver = false;

// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
  document.getElementById("grid").innerHTML = "";
  generateGrid(size);
//  generateBoard(size);
  attachListeners();
}

// visible GRID
function generateGrid(size) {
 
  for (let gridRow = 0; gridRow < size; gridRow++) {
    let tr = document.createElement("tr");

    for (let gridCol = 0; gridCol < size; gridCol++) {
      let td = document.createElement("td");

td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;

  if (gridCol % size == 0) {
      td.classList.add("sector-left");
}
  if (gridRow % size == 0) {
      td.classList.add("sector-top");
}
    
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  }
}


	// create the MINES. put within checkanswer
// function generateMines(clickedRow, clickedCol, newMines = totalMines) {
//   totalMines = newMines;

	// RESET everything first. *in case* validate board regenerates board due to unsolvability.
// for (let r = 0; r < size; r++) {
// for (let c = 0; c < size; c++) {
// let cell = ensureCell(r, c)
// cell.mine = false
// cell.adjacent = 0
// }}

	// then place mines
//  let minesNumber = 0;
//  let mineCol = 0;
//  let mineRow = 0;

//  while (minesNumber < totalMines) {
//    mineCol = Math.floor(Math.random() * size); // *** 8x8 sector. just need to set sector?
//    mineRow = Math.floor(Math.random() * size);
//    if (mineCol == clickedCol && mineRow == clickedRow) continue;
//      let potentialMine = ensureCell(mineRow, mineCol)
//    if (
//      potentialMine.mine == true ||
//      isAdjacent(mineRow, mineCol, clickedRow, clickedCol) // if mine or if is adjacent to the cell
//    )
//      continue; // skip!

//    potentialMine.mine = true; // set the mine flag
//    minesNumber++;
//  }
//  console.log("mines placed");

  // count adjacent once all mines placed
  // For each cell, loop through its 8 neighbors
  // If neighbor is in bounds and has a mine, increment adjacent count

//  for (let r = 0; r < size; r++) {
//    for (let c = 0; c < size; c++) {
//      let cell = ensureCell(r, c); // shouldn't this be ensured earlier?
//      let count = 0;
//      for (let [nr, nc] of cell.neighbours) {
//        let neighbour = ensureCell(nr, nc)
//        if (neighbour.mine) count++;
//      }
//      cell.adjacent = count;
//    }}
//  console.log("adjacent count completed");
// }

// ==== GAME LOGIC ====

function handleClicks(r, c, cellEl) {
 if (gameOver) return;
let cell = ensureCell(r, c)

if (!cell.revealed) {
  revealCell(r, c, cellEl);
// } else {
//   chordCell(r, c);
// }
}

// function checkAnswer(clickedRow, clickedCol, clickedCell) { // need to adjust to check current sector
//   if (firstClick) {
//    generateMines(clickedRow, clickedCol);

    // validate board after generating mines
//    let isValid = validateBoard(clickedRow, clickedCol);
//    if (!isValid) {
//      let attempts = 0;
//      while (!isValid && attempts < 10) {
//        generateMines(clickedRow, clickedCol);
//        isValid = validateBoard(clickedRow, clickedCol);
//        attempts++;
//      }
//      if (!isValid && attempts >= 10) {
//        document.getElementById("feedback").textContent =
//          "Something went wrong, please start a new game.";
//      }
//    }

//    firstClick = false;
//    revealCell(clickedRow, clickedCol, clickedCell);
//  } else {
//    revealCell(clickedRow, clickedCol, clickedCell);
//    checkWin();
//  }}

function revealCell(clickedRow, clickedCol, clickedCell) {
  let cell = ensureCell(clickedRow, clickedCol);
  if (cell.revealed || cell.flagged) return;
  cell.revealed = true;
  clickedCell.classList.add("revealed");

//  if (cell.mine) {
//    clickedCell.classList.add("mine");
//    triggerGameOver();
//    return; // need this cuz after running gameOver(), it will come back to this
//  }
//  if (cell.adjacent > 0) {
//    clickedCell.textContent = cell.adjacent;
//    return;
//  }
  // adjacent == 0 --> cascade

  for (let [nr, nc] of cell.neighbours) {
let neighbour = ensureCell(nr, nc)
    if (neighbour.flagged) continue;

    let neighbourCell = document.getElementById(`cell-${nr}-${nc}`);
if (!neighbourCell) continue;
    revealCell(nr, nc, neighbourCell); // CASCADE!!
  }
}

function chordCell(clickedRow, clickedCol) {
let cell = ensureCell(clickedRow, clickedCol);
if (!cell.revealed || cell.adjacent == 0) return;
let flagged = 0
let hidden = []
for (let [nr, nc] of cell.neighbours) {
let neighbour = ensureCell(nr, nc)
if (neighbour.flagged) flagged++;
else if (!neighbour.revealed) hidden.push([nr, nc])
}
if (flagged == cell.adjacent) {
hidden.forEach(([nr, nc]) => {
let el = document.getElementById(`cell-${nr}-${nc}`);
if (!el) return;
revealCell(nr, nc, el)
})}}

// function checkWin() {
//  let revealedCount = 0;
//  for (let r = 0; r < size; r++) {
//    for (let c = 0; c < size; c++) {
//      let cellData = ensureCell(r, c);
//      if (!cellData.mine && cellData.revealed == true) {
//        // just check non mines in case.
//        revealedCount++;
//      }}}

//  if (revealedCount == size * size - totalMines) {
//    gameOver = true;
//    for (let r = 0; r < size; r++) {
//      for (let c = 0; c < size; c++) {
//        let cellData = ensureCell(r, c);
//        if (cellData.mine == true && !cellData.revealed) {
//          let cellElement = document.getElementById(`cell-${r}-${c}`);
//          cellElement.textContent = "ðŸ’£"; // add flag
//        }
//        cellData.revealed = true;
//        document.getElementById("feedback").textContent = "You win!";
//      }}}}

function triggerGameOver() {
gameOver = true
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      let cellData = ensureCell(r, c);
      let cellElement = document.getElementById(`cell-${r}-${c}`);

      if (cellData.mine) {
        cellData.revealed = true;
        cellElement.classList.add("mine");
        cellElement.textContent = "ðŸ’£"; // add flag
      }
    }
  }
}

function resetGame(newSize = size, newMines = totalMines) {
  size = newSize;
  totalMines = newMines;
  document.getElementById("feedback").textContent = "";
  board = new Map();
//  generateBoard(size);
  document.getElementById("grid").innerHTML = "";
  generateGrid(size);
//  firstClick = true;
  gameOver = false;
  attachListeners();
}

function isAdjacent(r, c, clickedRow, clickedCol) {
  // check how far apart is 2 cells (for generating mines)
  return Math.abs(r - clickedRow) <= 1 && Math.abs(c - clickedCol) <= 1;
}

function toggleFlag(e) {
  if (gameOver) return;
  let clickedCell = e.target;
  e.preventDefault();
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
let cell = ensureCell(clickedRow, clickedCol)
  if (cell.revealed == true) {
    return;
  } else if (cell.flagged) {
    cell.flagged = false;
    clickedCell.textContent = ""; // no flag
    clickedCell.classList.remove("flagged");
  } else {
    cell.flagged = true;
    clickedCell.textContent = "ðŸš©"; // add flag
    clickedCell.classList.add("flagged");
  }
}

function revealHint() {
  let safeCell = findGuaranteedSafeCell();
  if (safeCell) {
    highlightCell(safeCell.r, safeCell.c);
  } else {
    document.getElementById("feedback").textContent =
      "No guaranteed safe move.";
  }
}

function findGuaranteedSafeCell() { // incomplete hint system
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      let cell = ensureCell(r, c);
      if (!cell.revealed || cell.adjacent == 0) continue;

      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr == 0 && dc == 0) continue;
          let neighbourRow = r + dr;
          let neighbourCol = c + dc;
          
          let neighbourCell = ensureCell(neighbourRow, neighbourCol);
          // ****
        }
      }
    }
  }
}

function getNeighbourCoords(r, c) {
  let neighbours = [];

  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr == 0 && dc == 0) continue;
      let neighbourRow = r + dr;
      let neighbourCol = c + dc;

      neighbours.push([neighbourRow, neighbourCol]);
    }
  }
  return neighbours;
}

function highlightCell(r, c) {
  let cellElement = document.getElementById(`cell-${r}-${c}`);
  cellElement.classList.add("hint");

  // Remove highlight after short delay
  setTimeout(() => {
    cellElement.classList.remove("hint");
  }, 1500);
}

// function countKnownMines(r, c) {
// let count = 0
// for (let [nr, nc] of ensureCell(r, c).neighbours) {
// let n = ensureCell(nr, nc)
// if (n.mine == "mine") count++
// }
// return count
// }


// ==== UI + INTERACTION ====

function disableInputs() {
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.addEventListener("click", onClick); // left click
  });
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleFlag); // right click
  });
  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame(size, totalMines);
  });
  document.getElementById("hintBtn").addEventListener("click", () => {
    revealHint();
  });


  // phone long tap
  cells.forEach((cell) => {
    let pressTimer;
    let longPressTriggered = false;

    cell.addEventListener("touchstart", (e) => {
      e.preventDefault();
      longPressTriggered = false;
      pressTimer = setTimeout(() => {
        toggleFlag(e);
        longPressTriggered = true;
      }, 600); // long press
    });

    cell.addEventListener("touchend", (e) => {
      clearTimeout(pressTimer);
      if (!longPressTriggered) {
        let r = parseInt(cell.dataset.row);
        let c = parseInt(cell.dataset.col);
        let cellData = ensureCell(r, c);
    
handleClicks(r, c, cell);
      }
    });
  });
}

function onClick(e) {
if (!e.target.classList.contains("cell")) return;
let cellEl = e.target;
  let x = parseInt(cellEl.dataset.row);
  let y = parseInt(cellEl.dataset.col);
handleClicks(x, y, cellEl);
}


// ==== BOARD VALIDATION ====

// function validateBoard(clickedRow, clickedCol) {
  // use after firstclick
  // Step 1: Setup

  // Create a list of revealed cells starting from the first click
  // creates a 2D array (same shape as your board) where each cell starts as false, meaning not revealed
  // revealedMap is for keeping track of the player, as though he is actually playing the board, like checkAnswer(e)

//  let revealedMap = Array(size)
//    .fill()
//    .map(() => Array(size).fill(false));

  // Create a list of flagged cells (initially empty)
  // tracks whether a cell is flagged in your simulation

//  let flaggedMap = Array(size)
//    .fill()
//    .map(() => Array(size).fill(false));

  // Step 2: Simulate logical deduction
  // Loop through revealed cells
  // For each cell with a number:
  //   - Count hidden neighbors
  //   - Count flagged neighbors
  //   - If adjacent == flagged count â†’ reveal remaining hidden neighbors
  //   - If adjacent == hidden count â†’ flag all hidden neighbors

//  cascadeReveal(clickedRow, clickedCol, revealedMap);

  // Step 3: Track progress
  // Keep a counter of how many non-mine cells are revealed (using flaggedMap)
  // Stop when no new cells are revealed in a loop (change = false ==> exit)
//  let change = true;
//  while (change) {
//    change = false; // rmb to add change = true after logic, so that it continues to run as long as there are new reveals

//    for (let row = 0; row < size; row++) {
//      for (let col = 0; col < size; col++) {
//        if (!revealedMap[row][col]) continue; // skip if it's not yet opened

//        let cell = ensureCell(row, col);
//        if (cell.adjacent == 0) continue;

//        let hidden = [];
//        let flagged = 0;
//        for (let [nr, nc] of cell.neighbours) {
//          if (flaggedMap[nr][nc])
//            flagged++; // count how many flagged cells are in the adjacent of this cell
//          else if (!revealedMap[nr][nc]) hidden.push([nr, nc]);
//        }

//        if (hidden.length > 0) {
          // hidden.length > 0 meaning there's still hidden cells
          // Condition 1: all adjacent mines flagged ==> rest are safe
//          if (cell.adjacent == flagged) {
//            hidden.forEach(([nr, nc]) => {
//              cascadeReveal(nr, nc, revealedMap);
//            });
//            change = true;
//          }

          // Condition 2: all adjacent is hidden ==> adjacents are mines ==> flag them
//          if (cell.adjacent == hidden.length + flagged) {
            // + flagged to account for those already flagged
//            hidden.forEach(([nr, nc]) => {
//              flaggedMap[nr][nc] = true;
//            });
//            change = true;
//          }}}}}

  // Step 4: Evaluate
  // If revealed count == total safe cells â†’ return true (valid board)
  // Else â†’ return false (board requires guessing)

//  let revealedSafe = 0;
//  let totalSafeCells = size * size - totalMines;
//  for (let r = 0; r < size; r++) {
//    for (let c = 0; c < size; c++) {
//      let cellData = ensureCell(r, c)
//      if (revealedMap[r][c] && cellData.mine == false) {
//        revealedSafe++;
//      }}}
//  return revealedSafe == totalSafeCells;
//  }

// Step 5: Retry logic (outside this function)
// If validateBoard() returns false, regenerate mines and try again
// already put in generateMines(), after first click

function cascadeReveal(r, c, revealedMap) { // bound by size of sector
if (r < 0 || c < 0 || r >= size || c >= size) return;
if (revealedMap[r][c]) return;

  revealedMap[r][c] = true;
let cell = ensureCell(r, c)
  if (cell.adjacent > 0) return;
  for (let [nr, nc] of cell.neighbours) {
    cascadeReveal(nr, nc, revealedMap); // CASCADE!!
  }
}


// ==== INFINITY HELPERS ====
// no longer set grid/board size. returns the exact coord of that cell

function key(x, y) {
  return `${x},${y}`;
}

function getCell(x, y) {
  return board.get(key(x, y));
}

function setCell(x, y, cell) {
  board.set(key(x, y), cell);
}

function ensureCell(x, y) {
  if(!board.has(key(x, y))) {
    board.set(key(x, y), createEmptyCell(x, y));
  }
return board.get(key(x, y));
}

function createEmptyCell(x, y) {
return {
        x, y,
        mine: "unknown", 	// safe/mine/unknown
        revealed: false,
        adjacent: null,
        flagged: false,
        neighbours: getNeighbourCoords(x, y)
  }
console.log("board generated");
}

</script>

</body>
</html>
