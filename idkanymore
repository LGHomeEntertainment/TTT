<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>B&W</title>

    <style>
      /* Container for the grid */
      #grid {
        border-collapse: collapse;
        margin: 20px auto;
      }
      
      /* Each cell */
      .cell {
        width: 30px;
        height: 30px;
        background-color: grey;
        color: black;
        border: 1px solid #999;
        padding: 0;
        font-weight: bold;
        font-size: 16px;
        text-align: center;
        line-height: 30px;
        cursor: pointer;
        user-select: none;
      }
      
      .cell.black {
        background-color: black;
        color: white;
      }
      
      .cell.grey {
        background-color: grey;
        color: black;
      }
      
      .cell.white {
        background-color: white;
        color: black;
      }
      
      .cell.error {
        color: red;
      }
    </style>

  </head>
  <body>
    <h1>Colour</h1>

    <table id="grid">
      <!-- JS will generate rows and cells -->
    </table>

    <div>
      <p id="feedback"></p>
    </div>

    <div>
      <button id="resetBtn">Start a new game</button>
    </div>

    <label
      >Grid size:
      <input type="number" id="gridSizeInput" value="10" min="5" max="20" />
    </label>

    <button id="applyBtn">Apply</button>

<script>


// ==== GLOBALs + CONSTANTS ====

let gridSize = 10; // start with 10, easier to adjust later
let blackCell = Math.floor(Math.random() * 11) + 40;
let board = [];
let grid = [];
let gameOver = false;
let sectorSize = Math.max(3, Math.floor(gridSize / 3)); // dynamic sector size
let errorCells = new Set(); // if error, errorCells.add("1,5") .delete .has .... use string.
let anchorCount = 0;
document.addEventListener("DOMContentLoaded", initialise);

// === Game Setup ===
function initialise() {
  generateValidBoard();
  let puzzle = createPuzzle();
  board = puzzle;
  generateGrid();
  addVisualNumbers(board);
  attachListeners();
}

// === Board Generation ===
function generateValidBoard() {
  let attempts = 0;
  let maxAttempts = 200;
  do {
    generateBoard(gridSize); // empty board
    generateCells(); // fill logic
    attempts++;
    if (attempts > maxAttempts) {
      document.getElementById("feedback").textContent =
        "Too many retries, stopping.";
      break;
    }
  } while (!checkAnchor());
  console.log("board generated with anchors")
}

function generateBoard(gridSize) {
  board = []; // clear the board in case there's looping in other functions
  for (let row = 0; row < gridSize; row++) {
    let rowData = [];
    for (let col = 0; col < gridSize; col++) {
      rowData.push({
        colour: "grey", // "grey", "black", "white"
        state: "neutral", // "neutral" / "revealed" / "error"
        adjacent: 0, // use this for checking win
	visibleNumber: "", // use this for solving clues
        isBlack: false, // determines if cell is black or white
        displayed: true, // number is showing or not
        isAnchor: false, // points to start deductions from
	hardAnchor: false,
        sectorID:
          Math.floor(row / sectorSize) + "-" + Math.floor(col / sectorSize),
      });
    }
    board.push(rowData);
  }
}

function generateCells() {
  let blackNumber = 0;
  let col = 0;
  let row = 0;

  while (blackNumber < blackCell) {
    col = Math.floor(Math.random() * gridSize);
    row = Math.floor(Math.random() * gridSize);
    if (board[row][col].isBlack == true) continue;

    board[row][col].isBlack = true; // set the signal flag
    blackNumber++;
  }

  // count adjacency
  let boardCol = 0;
  let boardRow = 0;

  for (boardRow = 0; boardRow < gridSize; boardRow++) {
    for (boardCol = 0; boardCol < gridSize; boardCol++) {
board[boardRow][boardCol].adjacent = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          let neighbourRow = boardRow + dr;
          let neighbourCol = boardCol + dc;

          if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
          if (neighbourCol < 0 || neighbourCol >= gridSize) continue;

          if (board[neighbourRow][neighbourCol].isBlack) {
            if (isAdjacent(neighbourRow, neighbourCol, boardRow, boardCol)) {
              board[boardRow][boardCol].adjacent++;
            }}}}
board[boardRow][boardCol].visibleNumber = board[boardRow][boardCol].adjacent;
board[boardRow][boardCol].displayed = true;
    }} 
validateBoard()
}

function createPuzzle() {
let puzzleBoard = cloneBoard(board)
assignHardAnchors(puzzleBoard, 40, 50)
let hiddenTarget = 10 // gridSize * gridSize * 0.5 // 50% hidden
let hiddenCount = 0
let attempts = 0
let maxAttempts = gridSize * gridSize * 100

while (hiddenCount < hiddenTarget && attempts < maxAttempts) {
attempts++
console.log("attempting to hide")
let r = Math.floor(Math.random() * gridSize)
let c = Math.floor(Math.random() * gridSize)
if (!puzzleBoard[r][c].displayed || puzzleBoard[r][c].hardAnchor) continue;

let testBoard = cloneBoard(puzzleBoard) 
testBoard[r][c].displayed = false
testBoard[r][c].visibleNumber = ""
if (hasUniqueSolution(testBoard)) { 
puzzleBoard[r][c].displayed = false
puzzleBoard[r][c].visibleNumber = "";
hiddenCount++
console.log(`Hiding cell ${r},${c}`)
}}
return puzzleBoard
}

// === ANCHORS ===
function checkAnchorSpread(
  minPerSector = Math.max(1, Math.floor(gridSize / 10))
) {
  let sectorCount = {};
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      if (board[r][c].isAnchor) {
        let id = board[r][c].sectorID;
        sectorCount[id] = (sectorCount[id] || 0) + 1;
      }
    }
  }
  return Object.values(sectorCount).every((count) => count >= minPerSector);
}


function checkAnchor() {
  let anchors = calcAnchorCount(board, gridSize);
  return validAnchorCount(anchors, gridSize) && checkAnchorSpread();
}

function calcAnchorCount(board, gridSize) {
  let anchorCount = 0;
  for (row = 0; row < gridSize; row++) {
    for (col = 0; col < gridSize; col++) {
      let boardData = board[row][col];
      if (boardData.adjacent == 0 || boardData.adjacent == 9) {
        anchorCount++;
        boardData.isAnchor = true;
       // boardData.displayed = true;
      }
      if (row == 0 || row == gridSize - 1 || col == 0 || col == gridSize - 1) {
        if (boardData.adjacent == 6) {
          anchorCount += 0.8;
          boardData.isAnchor = true;
       //   boardData.displayed = true;
        }
      }
      if (
        (row == 0 || row == gridSize - 1) &&
        (col == 0 || col == gridSize - 1)
      ) {
        if (boardData.adjacent == 4) {
          anchorCount += 0.6;
          boardData.isAnchor = true;
     //     boardData.displayed = true;
        }
      } else if (boardData.adjacent == 8 || boardData.adjacent == 1) {
        anchorCount += 0.2;
        boardData.isAnchor = true;
    //    boardData.displayed = true;
      }
    }
  }
  return anchorCount;
}

function validAnchorCount(anchorCount, gridSize) {
  // just for determining min/max. no calcs
  let minAnchor = gridSize * gridSize * 0.08;
  // let maxAnchor = gridSize * gridSize * 0.5 // removed cuz criteria too tight
  return anchorCount > minAnchor; // && anchorCount < maxAnchor
}


function assignHardAnchors(puzzleBoard, minHard, maxHard) {
  const sectors = {};
  const gridSize = puzzleBoard.length;

  // Step 0: Group anchors by sector
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      const cell = puzzleBoard[row][col];
      if (cell.isAnchor) {
        const sectorKey = cell.sectorID;
        if (!sectors[sectorKey]) sectors[sectorKey] = [];
        sectors[sectorKey].push({ row, col });
      }
    }
  }

  const hardAnchors = [];

  // Step 1: Guarantee one per sector
  for (const key in sectors) {
    const anchorsInSector = sectors[key];
    if (anchorsInSector.length > 0) {
      const pickIndex = Math.floor(Math.random() * anchorsInSector.length);
      hardAnchors.push(anchorsInSector.splice(pickIndex, 1)[0]);
    }
  }

  // Step 2: Enforce maxHard immediately
  if (hardAnchors.length > maxHard) {
    hardAnchors.length = maxHard;
  }

  // Step 3: Add more anchors if below minHard
  const remainingAnchors = Object.values(sectors).flat();
  remainingAnchors.sort(() => Math.random() - 0.5);

  const totalAnchors = hardAnchors.length + remainingAnchors.length;
  let hardCount = Math.max(minHard, hardAnchors.length);
  hardCount = Math.min(hardCount, maxHard);

  while (hardAnchors.length < hardCount && remainingAnchors.length > 0) {
    hardAnchors.push(remainingAnchors.pop());
  }

  // Step 4: If still short, convert random non-anchor cells
  if (hardAnchors.length < minHard) {
    const extraNeeded = minHard - hardAnchors.length;
    const nonAnchors = [];

    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const cell = puzzleBoard[row][col];
        if (!cell.isAnchor && !cell.hardAnchor) {
          nonAnchors.push({ row, col });
        }
      }
    }

    nonAnchors.sort(() => Math.random() - 0.5);

    for (let i = 0; i < extraNeeded && i < nonAnchors.length; i++) {
      const { row, col } = nonAnchors[i];
      puzzleBoard[row][col].hardAnchor = true;
      puzzleBoard[row][col].displayed = true;
      // Optional: mark them as anchors if needed
      puzzleBoard[row][col].isAnchor = true;
      hardAnchors.push({ row, col });
    }
  }

  // Step 5: Mark all chosen hard anchors
  for (const { row, col } of hardAnchors) {
    puzzleBoard[row][col].hardAnchor = true;
    puzzleBoard[row][col].displayed = true;
  }

  console.log(`Final hard anchors: ${hardAnchors.length}`);
}

// === Validation ===

function validateBoard(puzzleBoard, sectors) {
//  const gridSize = puzzleBoard.length;

  // 1. Check sector constraints
  for (const key in sectors) {
    const sector = sectors[key];
    const anchorsInSector = [];
    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const cell = puzzleBoard[row][col];
        if (cell.sectorID === key && cell.isAnchor) {
          anchorsInSector.push(cell);
        }
      }
    }

    if (anchorsInSector.length < sector.required) {
      console.warn(`Sector ${key} has too few anchors (${anchorsInSector.length}) for required ${sector.required}`);
      return false;
    }
  }

  // 2. Check hard anchors visibility
  const hardAnchors = [];
  for (let row = 0; row < gridSize; row++) {
    for (let col = 0; col < gridSize; col++) {
      const cell = puzzleBoard[row][col];
      if (cell.hardAnchor) hardAnchors.push(cell);
    }
  }

  if (hardAnchors.length === 0) {
    console.warn("No hard anchors found â€” puzzle may be too hard.");
    return false;
  }

  // 3. Attempt to solve the puzzle
  const cloneBoard = JSON.parse(JSON.stringify(puzzleBoard));
  const cloneSectors = JSON.parse(JSON.stringify(sectors));

  const solved = solvePuzzle(cloneBoard, cloneSectors);
  if (!solved) {
    console.warn("Puzzle is unsolvable.");
    return false;
  }

  console.log("Puzzle validated successfully!");
  return true;
}



function solvePuzzle(puzzleBoard, sectors) {
  const gridSize = puzzleBoard.length;

  // Helper: Get candidates for each sector
  function getSectorCandidates() {
    const candidates = {};
    for (const key in sectors) {
      candidates[key] = [];
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          const cell = puzzleBoard[row][col];
          if (cell.sectorID === key && !cell.hardAnchor && !cell.confirmedSafe) {
            candidates[key].push({ row, col });
          }
        }
      }
    }
    return candidates;
  }

  // Helper: Apply direct rules
  function applyDirectRules(candidates) {
    let changed = false;
    for (const key in sectors) {
      const sector = sectors[key];
      const remainingAnchors = sector.required - sector.placed;
      const cells = candidates[key];

      if (remainingAnchors === 0) {
        // Mark all candidates as safe
        for (const { row, col } of cells) {
          puzzleBoard[row][col].confirmedSafe = true;
        }
        candidates[key] = [];
        changed = true;
      } else if (remainingAnchors === cells.length) {
        // All candidates must be anchors
        for (const { row, col } of cells) {
          puzzleBoard[row][col].hardAnchor = true;
          puzzleBoard[row][col].displayed = true;
          sector.placed++;
        }
        candidates[key] = [];
        changed = true;
      }
    }
    return changed;
  }

  // Helper: Intersection reasoning
  function applyIntersectionRules(candidates) {
    let changed = false;
    const keys = Object.keys(candidates);
    for (let i = 0; i < keys.length; i++) {
      for (let j = i + 1; j < keys.length; j++) {
        const A = keys[i], B = keys[j];
        const overlap = candidates[A].filter(cell =>
          candidates[B].some(c => c.row === cell.row && c.col === cell.col)
        );
        if (overlap.length > 0) {
          const sectorA = sectors[A], sectorB = sectors[B];
          const remainingA = sectorA.required - sectorA.placed;
          const remainingB = sectorB.required - sectorB.placed;

          // Example logic: If overlap size == remainingB and B needs all overlap cells
          if (overlap.length === remainingB && remainingA > overlap.length) {
            // Deduce that A must take some non-overlap cells
            const nonOverlap = candidates[A].filter(cell =>
              !overlap.some(o => o.row === cell.row && o.col === cell.col)
            );
            for (const { row, col } of nonOverlap) {
              puzzleBoard[row][col].hardAnchor = true;
              puzzleBoard[row][col].displayed = true;
              sectorA.placed++;
            }
            candidates[A] = [];
            changed = true;
          }
        }
      }
    }
    return changed;
  }

  // Recursive solver with backtracking
  function backtrack() {
    let candidates = getSectorCandidates();

    // Apply rules until no change
    let progress;
    do {
      progress = applyDirectRules(candidates) || applyIntersectionRules(candidates);
      candidates = getSectorCandidates();
    } while (progress);

    // Check if solved
    if (Object.values(candidates).every(arr => arr.length === 0)) return true;

    // Pick a guess (first candidate from largest sector)
    const [sectorKey, cells] = Object.entries(candidates).sort((a, b) => b[1].length - a[1].length)[0];
    if (!cells || cells.length === 0) return false;

    for (const { row, col } of cells) {
      // Make a guess
      puzzleBoard[row][col].hardAnchor = true;
      puzzleBoard[row][col].displayed = true;
      sectors[sectorKey].placed++;

      if (backtrack()) return true;

      // Undo guess
      puzzleBoard[row][col].hardAnchor = false;
      puzzleBoard[row][col].displayed = false;
      sectors[sectorKey].placed--;
    }
    return false;
  }

  return backtrack() ? puzzleBoard : null;
}





// === Clicky UI + Resets (reusable) ===
function handleCellClick(e) {
  // left click turns it BLACK, even from white
  let clickedCell = e.target;
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  let boardData = board[clickedRow][clickedCol];
  if (gameOver) return;
  if (boardData.state == "neutral" || boardData.colour == "white") {
    boardData.state = "revealed";
    boardData.colour = "black";
    clickedCell.classList.remove("grey", "white");
    clickedCell.classList.add("black");
    updateArea(clickedRow, clickedCol);
    checkWin();
  } else if (boardData.state == "revealed" && boardData.colour == "black") {
    boardData.state = "neutral";
    boardData.colour = "grey";
    clickedCell.classList.remove("black");
    clickedCell.classList.add("grey");
    updateArea(clickedRow, clickedCol);
  }
}

function toggleWhite(e) {
  // right click turns it WHITE
  if (gameOver) return;
  let clickedCell = e.target;
  e.preventDefault();
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  let boardData = board[clickedRow][clickedCol];

  if (boardData.state == "neutral" || boardData.colour == "black") {
    boardData.state = "revealed";
    boardData.colour = "white";
    clickedCell.classList.remove("grey", "black");
    clickedCell.classList.add("white");
    updateArea(clickedRow, clickedCol);
    checkWin();
  } else if (boardData.state == "revealed" && boardData.colour == "white") {
    boardData.state = "neutral";
    boardData.colour = "grey";
    clickedCell.classList.remove("white");
    clickedCell.classList.add("grey");
    updateArea(clickedRow, clickedCol);
  }
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.addEventListener("click", handleCellClick); // left click
  });
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleWhite); // right click
  });
  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame(gridSize);
  });
  document.getElementById("applyBtn").addEventListener("click", customise);

  // phone long tap
  cells.forEach((cell) => {
    let pressTimer;
    let longPressTriggered = false;

    cell.addEventListener("touchstart", (e) => {
      e.preventDefault();
      longPressTriggered = false;
      pressTimer = setTimeout(() => {
        toggleWhite(e);
        longPressTriggered = true;
      }, 200); // long press
    });

    cell.addEventListener("touchend", (e) => {
      clearTimeout(pressTimer);
      if (!longPressTriggered) {
        handleCellClick(e); // treat as single tap
      }
    });
  });
}

function triggerGameOver() {
  // disableInputs
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function resetGame(newSize = gridSize) {
  gridSize = newSize;
  document.getElementById("feedback").textContent = "";
  board = [];
  generateBoard(gridSize);
  document.getElementById("grid").innerHTML = "";
  generateGrid(gridSize);
  generateCells();
  gameOver = false;
  errorCells = new Set();
  attachListeners();
}

function customise() {
  let inputSize = document.getElementById("gridSizeInput").value;
  let newSize = gridSize;
  if (inputSize !== "") {
    newSize = parseInt(inputSize);
  }
  resetGame(newSize);
}

// === UI Rendering ===
function generateGrid() {
  grid = [];
  for (let gridRow = 0; gridRow < gridSize; gridRow++) {
    let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < gridSize; gridCol++) {
      let td = document.createElement("td");
      td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  } 
}

function addVisualNumbers(finalBoard) {
  let boardCol = 0;
  let boardRow = 0;
  for (boardRow = 0; boardRow < gridSize; boardRow++) {
    for (boardCol = 0; boardCol < gridSize; boardCol++) {
      let cellElement = document.getElementById(`cell-${boardRow}-${boardCol}`);
      if (finalBoard[boardRow][boardCol].displayed) {
        cellElement.textContent = String(finalBoard[boardRow][boardCol].visibleNumber);
      } else {
        cellElement.textContent = "";
      }
    }
  }
}

// === Tutorial ===


// === Helpers ===
function cloneBoard(board) {
  let testBoard = [];
  for (let row = 0; row < gridSize; row++) {
    let rowTest = [];
    for (let col = 0; col < gridSize; col++) {
      rowTest.push({ ...board[row][col] });
    }
    testBoard.push(rowTest);
  }
  return board.map(row => row.map(cell => ({ ...cell }))); 
  // only by returning, we can access it in the validate board (). it's not really global though
}

function neighbourPositions(row, col, size) {
let pos = [];
for (let nr = row - 1; nr <= row + 1; nr++) {
  for (let nc = col - 1; nc <= col + 1; nc++) {
if( nr < 0 || nr >= size || nc < 0 || nc >= size) continue;
pos.push([nr, nc]);}}
return pos
}

function neighbourCountsForSet(posList, testBoard) {
let blacks = 0, whites = 0, unknown = 0;
for (let [nr, nc] of posList) {
  let cell = testBoard[nr][nc];
if (cell.colour == "black") blacks++;
else if (cell.colour == "white") whites++;
else unknown++;
}
return { blacks, whites, unknown};
}

function countImmediate(clickedRow, clickedCol) {
  let boardData = board[clickedRow][clickedCol];
  let blackCount = 0;
  let whiteCount = 0;
  let cellCount = 0;
  for (let r = clickedRow - 1; r <= clickedRow + 1; r++) {
    for (let c = clickedCol - 1; c <= clickedCol + 1; c++) {
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) continue;
      cellCount++;
      let nData = board[r][c];
      if (nData.colour == "black") {
        blackCount++;
      } else if (nData.colour == "white") {
        whiteCount++;
      }
    }
  }
  return { blackCount, whiteCount, cellCount };
}

function checkImmediate(clickedRow, clickedCol) {
  let { blackCount, whiteCount, cellCount } = countImmediate(
    clickedRow,
    clickedCol
  );
  let boardData = board[clickedRow][clickedCol];
  if (!boardData.displayed) return;
  let isError =
    blackCount > boardData.adjacent ||
    whiteCount > cellCount - boardData.adjacent;
  let cellElement = document.getElementById(`cell-${clickedRow}-${clickedCol}`);
  let coords = `${clickedRow},${clickedCol}`;
  if (isError) {
    cellElement.classList.add("error");
    errorCells.add(coords);
  } else if (!isError) {
    cellElement.classList.remove("error");
    errorCells.delete(coords);
  }
}

function updateArea(clickedRow, clickedCol) {
  // not accurate.
  for (let r = clickedRow - 2; r <= clickedRow + 2; r++) {
    for (let c = clickedCol - 2; c <= clickedCol + 2; c++) {
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) continue;
      if (!board[r] || !board[r][c]) continue; // just in case it checks outside
      checkImmediate(r, c);
    }
  }
}

function checkWin() {
  if (errorCells.size > 0) return;
  let correctTile = 0;
  let incorrectTile = 0;
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      let cellData = board[r][c];
      if (cellData.state == "neutral") return;
      if (cellData.isBlack && cellData.colour == "black") {
        correctTile++;
      } else if (cellData.isBlack && cellData.colour != "black") {
        incorrectTile++;
      }
    }
  }
  if (correctTile == blackCell && incorrectTile == 0) {
    gameOver = true;
    triggerGameOver();
    document.getElementById("feedback").textContent = "You win! Good job.";
  }
}

function isAdjacent(r, c, clickedRow, clickedCol) {
  // check how far apart is 2 cells (mainly for generating clear area around the first click)
  return Math.abs(r - clickedRow) <= 1 && Math.abs(c - clickedCol) <= 1;
}

function maxValidCells(row, col, size) {
  // impt for cells at sides
  if ((row == 0 || row == size - 1) && (col == 0 || col == size - 1)) {
    return 4; // corner
  } else if (row == 0 || col == 0 || row == size - 1 || col == size - 1) {
    return 6; // border
  } else {
    return 9;
  }
}

function countNeighbours(row, col, testBoard) {
let unknown = 0
  let blacks = 0
  let whites = 0

for (let nr = row - 1; nr <= row + 1; nr++) {
  for (let nc = col - 1; nc <= col + 1; nc++) {
if (nr < 0 || nr >= testBoard.length || nc < 0 || nc >= testBoard.length) continue;

 let neighbourCell = testBoard[nr][nc] 

if (neighbourCell.colour == "grey") { unknown++ }
else if (neighbourCell.colour == "black") { blacks++ }
else if (neighbourCell.colour == "white") { whites++ }
}}
return { unknown, blacks, whites }
}


</script>

</body>
</html>
