<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>S&P</title>

  <style>
/* Container for the grid */
/* Container for the grid */
#grid {
  border-collapse: collapse;
  margin: 20px auto;
}

/* Each cell */
.cell {
  width: 30px;
  height: 30px;
  background-color: lightskyblue;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

.cell.green {
  background-color: green;
  color: green;
}
.cell.lightgreen {
  background-color: lightgreen;
  color: black;
}

.cell.yellow {
  background-color: yellow;
  color: black;
}

.cell.orange {
  background-color: orange;
  color: black;
}

.cell.red {
  background-color: red;
  color: white;
}

    
</style>

</head>
<body>

<h1>Signal & Ping</h1>

<table id="grid">
  <!-- JS will generate rows and cells -->
</table>


<div> 
  <p id="feedback"></p>
</div>

<div> 
  <button id="resetBtn">Start a new game</button>
</div>

<label>Grid size:
<input type="number" id="gridSizeInput" value="10" min="5" max="20">
</label>
<label>Signals:
  <input type="number" id="signalInput" value="10" min="1" max="100">
</label>
<button id="applyBtn">Apply</button>



<script>

// ==== GLOBALs + CONSTANTS ====

let gridSize = 10; 
let totalSignals = 15;
let firstClick = true;
let board = [];
let grid = [];
// let gameOver = false;
// let fadeout = 5000;

// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
  generateGrid();
  generateBoard(gridSize);
  attachListeners();
}

// visible GRID
function generateGrid() {
  grid = [];
  for (let gridRow = 0; gridRow < gridSize; gridRow++) {
    let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < gridSize; gridCol++) {
      let td = document.createElement("td");
      td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  }
}

// create clear logic BOARD (the invisible one BTS)
function generateBoard(gridSize) {
  board = [];
  for (let row = 0; row < gridSize; row++) {
    let rowData = [];
    for (let col = 0; col < gridSize; col++) {
      rowData.push({
        signal: false, // actual status of the cell
        pinged: false, // has it been revealed
        flagged: false, // for flagging if it's a signal
        totalStrength: 0
      });
    }
    board.push(rowData);
  }
}

// create the SIGNALS. put within checkanswer
function generateSignals(clickedRow, clickedCol, newSignals = totalSignals) {
  totalSignals = newSignals;
  let signalNumber = 0;
  let signalCol = 0;
  let signalRow = 0;

  while (signalNumber < totalSignals) {
    signalCol = Math.floor(Math.random() * gridSize);
    signalRow = Math.floor(Math.random() * gridSize);
    if (signalCol == clickedCol && signalRow == clickedRow) continue;
    if (
      board[signalRow][signalCol].signal == true 
   //  || isAdjacent(signalRow, signalCol, clickedRow, clickedCol) // if signal or if is adjacent to the cell
    )
      continue; // skip!

    board[signalRow][signalCol].signal = true; // set the signal flag
board[signalRow][signalCol].totalStrength += 1.2;
    signalNumber++;
  }


  // calculate strength FOR ALL CELLS, but only for the immediate r2 area
  // If neighbor is in bounds and has a signal, increment adjacent count
  let cellStrength = 0
  let boardCol = 0;
  let boardRow = 0;
  let maxRadius = 2;

  for (boardRow = 0; boardRow < gridSize; boardRow++) {
    for (boardCol = 0; boardCol < gridSize; boardCol++) {
      for (let dr = -maxRadius; dr <= maxRadius; dr++) {
        for (let dc = -maxRadius; dc <= maxRadius; dc++) {
         
if (dr === 0 && dc === 0) continue;


          let neighbourRow = boardRow + dr;
          let neighbourCol = boardCol + dc;
          if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
          if (neighbourCol < 0 || neighbourCol >= gridSize) continue;
          if (board[neighbourRow][neighbourCol].signal == true) {
            let dx = neighbourRow - boardRow;
	    let dy = neighbourCol - boardCol;
 	    let distance = Math.sqrt(dx * dx + dy * dy);
if (distance > 0) {
board[neighbourRow][neighbourCol].totalStrength += 1 / distance
            }
          }
        }
      }
    }
  }
}

function isAdjacent(r, c, clickedRow, clickedCol) {
  // check how far apart is 2 cells (mainly for generating clear area around the first click)
  return Math.abs(r - clickedRow) <= 1 && Math.abs(c - clickedCol) <= 1;
}

// ==== GAME LOGIC ====

function handleCellClick(e) {
  let clickedCell = e.target;
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  // if (gameOver) return;
  if (firstClick) {
    generateSignals(clickedRow, clickedCol);

    firstClick = false;
    getCellColour(clickedRow, clickedCol, clickedCell);
  } else {
    getCellColour(clickedRow, clickedCol, clickedCell);
  }
}

function getStrengthColour(clickedRow, clickedCol, clickedCell) {
let cellStrength = board[clickedRow][clickedCol].totalStrength
let cellElement = document.getElementById(`cell-${clickedRow}-${clickedCol}`)
if (cellStrength >= 3) return "red";
if (cellStrength >= 1.5) return "orange";
if (cellStrength >= 0.4) return "yellow";
if (cellStrength > 0.1) return "lightgreen";
return "green";
}



function getCellColour(clickedRow, clickedCol, clickedCell) {
  let cellData = board[clickedRow][clickedCol];
  let cellElement = document.getElementById(`cell-${clickedRow}-${clickedCol}`); 
  cellElement.classList.add(getStrengthColour(clickedRow, clickedCol, clickedCell))
  cellData.pinged = true; // ‚Üê Mark as pinged!
  revealArea(clickedRow, clickedCol, clickedCell)
}

function revealArea(clickedRow, clickedCol, clickedCell) {
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
   //   if (dr == 0 && dc == 0) continue;

      let neighbourRow = clickedRow + dr;
      let neighbourCol = clickedCol + dc;
      if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
      if (neighbourCol < 0 || neighbourCol >= gridSize) continue;
      let cellData = board[neighbourRow][neighbourCol];
      
      if (!cellData.pinged) {
        cellData.pinged = true; // mark as revealed

        let cellElement = document.getElementById(`cell-${neighbourRow}-${neighbourCol}`);
        let colourClass = getStrengthColour(neighbourRow, neighbourCol, cellElement)
        cellElement.classList.add(colourClass); // show all empty cells within the 5 radius at the start
  //      fadeCell(cellElement, 2000, ["empty"], true);
      }
    }
  }
}

// function fadeCell(cell, delay = fadeout, removeClasses = [], clearText = true) {
//  setTimeout(() => {
//    removeClasses.forEach((cls) => cell.classList.remove(cls));
//    if (clearText) cell.textContent = "";
//  }, delay);
// }

function checkWin() {
  let correctFlags = 0;
  let incorrectFlags = 0;
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      let cellData = board[r][c];
      if (cellData.flagged) {
        if (cellData.signal) {
          correctFlags++;
        } else {
          incorrectFlags++;
        }
      }
    }
  }

  if (correctFlags == totalSignals && incorrectFlags == 0) {
    //  gameOver = true;

    document.getElementById("feedback").textContent = "You win!";
  }
}

function resetGame(newSize = gridSize, newSignals = totalSignals) {
  gridSize = newSize;
  totalSignals = newSignals;
  document.getElementById("feedback").textContent = "";
  board = [];
  generateBoard(gridSize);
  document.getElementById("grid").innerHTML = "";
  generateGrid(gridSize);
  firstClick = true;
  // gameOver = false;
  attachListeners();
}

function toggleFlag(e) {
  // if (gameOver) return;
  let clickedCell = e.target;
  e.preventDefault();
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  if (board[clickedRow][clickedCol].pinged == true) {
    return;
  } else if (board[clickedRow][clickedCol].flagged) {
    board[clickedRow][clickedCol].flagged = false;
    clickedCell.textContent = ""; // no flag
    clickedCell.classList.remove("flagged");
  } else {
    board[clickedRow][clickedCol].flagged = true;
    clickedCell.textContent = "üö©"; // add flag
    clickedCell.classList.add("flagged");
  }
  checkWin();
}

// ==== UI + INTERACTION ====

function disableInputs() {
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.addEventListener("click", handleCellClick); // left click
  });
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleFlag); // right click
  });
  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame(gridSize, totalSignals);
  });
  document.getElementById("applyBtn").addEventListener("click", customise);

  // phone long tap
  cells.forEach((cell) => {
    let pressTimer;
    let longPressTriggered = false;

    cell.addEventListener("touchstart", (e) => {
      e.preventDefault();
      longPressTriggered = false;
      pressTimer = setTimeout(() => {
        toggleFlag(e);
        longPressTriggered = true;
      }, 600); // long press
    });

    cell.addEventListener("touchend", (e) => {
      clearTimeout(pressTimer);
      if (!longPressTriggered) {
        handleCellClick(e); // treat as single tap
      }
    });
  });
}

function customise() {
  let inputSize = document.getElementById("gridSizeInput").value;
  let inputSignal = document.getElementById("signalInput").value;

  let newSize = gridSize;
  let newSignals = totalSignals;

  if (inputSize !== "") {
    newSize = parseInt(inputSize);
  }
  if (inputSignal !== "") {
    newSignals = parseInt(inputSignal);
  }
  resetGame(newSize, newSignals);
}

// ==== BOARD VALIDATION ====



</script>

</body>
</html>
