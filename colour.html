<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>B&W</title>

  <style>
/* Container for the grid */
/* Container for the grid */
#grid {
  border-collapse: collapse;
  margin: 20px auto;
}

/* Each cell */
.cell {
  width: 30px;
  height: 30px;
  background-color: grey;
  color: black;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

.cell.black {
  background-color: black;
  color: white;
}

.cell.grey {
  background-color: grey;
  color: black;
}

.cell.white {
  background-color: white;
  color: black;
}

.cell.error {
  color: red;
}

    
</style>

</head>
<body>

<h1>Colour</h1>

<table id="grid">
  <!-- JS will generate rows and cells -->
</table>


<div> 
  <p id="feedback"></p>
</div>

<div> 
  <button id="resetBtn">Start a new game</button>
</div>

<label>Grid size:
<input type="number" id="gridSizeInput" value="10" min="5" max="20">
</label>

<button id="applyBtn">Apply</button>



<script>

// ==== GLOBALs + CONSTANTS ====

let gridSize = 10; // start with 10, easier to adjust later
let blackCell = Math.floor(Math.random() * 11) + 40
// let firstClick = true;
let board = [];
let grid = [];
let gameOver = false;
let errorCells = new Set(); // if error, errorCells.add("1,5") .delete .has .... use string.


// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
  generateGrid();
  generateBoard(gridSize);
  generateCells();
  attachListeners();
}

// visible GRID
function generateGrid() {
  grid = [];
  for (let gridRow = 0; gridRow < gridSize; gridRow++) {
    let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < gridSize; gridCol++) {
      let td = document.createElement("td");
      td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  }
}

// create clear logic BOARD (the invisible one BTS)
function generateBoard(gridSize) {
  board = [];
  for (let row = 0; row < gridSize; row++) {
    let rowData = [];
    for (let col = 0; col < gridSize; col++) {
      rowData.push({
        colour: "grey", // original state
        state: "hidden", // can become "flagged" / "error"
        adjacent: 0,
        isBlack: false, // determines if cell is black or white
        number: 0, // the number shown on the cell. not all will show
        displayed: true
      });
    }
    board.push(rowData);
  }
}

// create the blackcells. put within checkanswer
function generateCells(clickedRow, clickedCol) {

  let blackNumber = 0;
  let col = 0;
  let row = 0;

  while (blackNumber < blackCell) {
    col = Math.floor(Math.random() * gridSize);
    row = Math.floor(Math.random() * gridSize);
    if (board[row][col].isBlack == true) continue;

    board[row][col].isBlack = true; // set the signal flag
    blackNumber++;
  }

  // count adjacent once all signal placed
  // For each cell, loop through its neighbors
  // If neighbor is in bounds and has a signal, increment adjacent count
  let boardCol = 0;
  let boardRow = 0;

  for (boardRow = 0; boardRow < gridSize; boardRow++) {
    for (boardCol = 0; boardCol < gridSize; boardCol++) {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {

          let neighbourRow = boardRow + dr;
          let neighbourCol = boardCol + dc;
          if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
          if (neighbourCol < 0 || neighbourCol >= gridSize) continue;
          if (board[neighbourRow][neighbourCol].isBlack == true) {
            if (isAdjacent(neighbourRow, neighbourCol, boardRow, boardCol)) {
              board[boardRow][boardCol].adjacent++;
            } 
          }
        }
      }
    }
  }
}

function isAdjacent(r, c, clickedRow, clickedCol) {
  // check how far apart is 2 cells (mainly for generating clear area around the first click)
  return Math.abs(r - clickedRow) <= 1 && Math.abs(c - clickedCol) <= 1;
}

// ==== GAME LOGIC ====

function handleCellClick(e) { // left click turns it white, even from black
  let clickedCell = e.target;
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
 let boardData = board[clickedRow][clickedCol]
  if (gameOver) return;
if (boardData.state == "hidden" || boardData.color == "black") {
boardData.state = "revealed"
boardData.color = "white"
clickedCell.classList.remove("grey", "black")
clickedCell.classList.add("white")
checkNeighbour(clickedRow, clickedCol, clickedCell)
checkWin();
} else if (boardData.state == "revealed" && boardData.color == "white") {
boardData.state = "hidden"
boardData.color = "grey"
clickedCell.classList.remove("white")
clickedCell.classList.add("grey")
checkNeighbour(clickedRow, clickedCol, clickedCell)
}


function checkNeighbour(clickedRow, clickedCol, clickedCell) { // on click/toggle, check 9 cells + neighbours (total 25) for errors/clear errors
let boardData = board[clickedRow][clickedCol]
for (let r = clickedRow - 2; r <= clickedRow + 2; r++) {
    for (let c = clickedCol - 2; c <= clickedCol + 2; c++) {
if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) continue;
let neighbourCell = document.getElementById(`cell-${r}-${c}`);
if 

redText(clickedRow, clickedCol, neighbourCell);

}



function redText(clickedRow, clickedCol, neighbourCell) { // for red text when number does not match
if (!board[clickedRow][clickedCol].display) return; // no number, ignore

//check for error, add classlist error to make css take the error text colour. or remove when no error
let boardData = board[clickedRow][clickedCol]
let blackCount = 0;
let whiteCount = 0;
for (let r = clickedRow - 1; r <= clickedRow + 1; r++) {
    for (let c = clickedCol - 1; c <= clickedCol + 1; c++) {
if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) continue;
if (board[r][c].colour == "black") { 
blackCount++
} else if (board[r][c].colour == "white") {
whiteCount++
}}}
// if number is 3, shows 3 black cells. so error = when black > number or when white > 9 - number. if grey still exists, doesnt matter
let coords = `${r},${c}`
if (blackCount > boardData.number || whiteCount > 9 - boardData.number) {
clickedCell.classList.add("error")
errorCells.add(coords)
} else if (blackCount <= boardData.number && whiteCount <= 9 - boardData.number)
clickedCell.classList.remove("error")
errorCells.delete(coords)
}



function checkWin() {
if (errorCells.size > 0) return;
  let correctFlags = 0;
  let incorrectFlags = 0;
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      let cellData = board[r][c];
      if (cellData.flagged) {
        if (cellData.isBlack) {
          correctFlags++;
        } else {
          incorrectFlags++;
        }
      }
    }
  }

  if (correctFlags == blackCell && incorrectFlags == 0) {
    gameOver = true;

    document.getElementById("feedback").textContent = "You win! Good job.";
  }
}

function resetGame(newSize = gridSize, newSignals = totalSignals) {
  gridSize = newSize;
  totalSignals = newSignals;
  document.getElementById("feedback").textContent = "";
  board = [];
  generateBoard(gridSize);
  document.getElementById("grid").innerHTML = "";
  generateGrid(gridSize);
  generateCells();
  gameOver = false;
  errorCells = [];
  attachListeners();
}

function toggleBlack(e) { // right click turns it black
  if (gameOver) return;
  let clickedCell = e.target;
  e.preventDefault();let clickedCell = e.target;
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
 let boardData = board[clickedRow][clickedCol]

if (boardData.state == "hidden" || boardData.color == "white") {
boardData.state = "revealed"
boardData.color = "black"
clickedCell.classList.remove("grey", "white")
clickedCell.classList.add("black")
redTextError();
checkWin();
} else if (boardData.state == "revealed" && boardData.color == "black") {
boardData.state = "hidden"
boardData.color = "grey"
clickedCell.classList.remove("black")
clickedCell.classList.add("grey")
redTextError();
}

// ==== UI + INTERACTION ====

function disableInputs() {
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.addEventListener("click", handleCellClick); // left click
  });
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleBlack); // right click
  });
  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame(gridSize);
  });
  document.getElementById("applyBtn").addEventListener("click", customise);

  // phone long tap
  cells.forEach((cell) => {
    let pressTimer;
    let longPressTriggered = false;

    cell.addEventListener("touchstart", (e) => {
      e.preventDefault();
      longPressTriggered = false;
      pressTimer = setTimeout(() => {
        toggleFlag(e);
        longPressTriggered = true;
      }, 600); // long press
    });

    cell.addEventListener("touchend", (e) => {
      clearTimeout(pressTimer);
      if (!longPressTriggered) {
        handleCellClick(e); // treat as single tap
      }
    });
  });
}

function customise() {
  let inputSize = document.getElementById("gridSizeInput").value;
  let newSize = gridSize;
  if (inputSize !== "") {
    newSize = parseInt(inputSize);
  }
  resetGame(newSize);
}

// ==== BOARD VALIDATION ====

// let solutionCount = 0;

// check for solution. when complete, check for another solution. if only 1 == unique, if 2, undo the hide, and return

</script>

</body>
</html>
