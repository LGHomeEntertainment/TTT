<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>B&W</title>

    <style>
      /* Container for the grid */
      #grid {
        border-collapse: collapse;
        margin: 20px auto;
      }
      
      /* Each cell */
      .cell {
        width: 30px;
        height: 30px;
        background-color: grey;
        color: black;
        border: 1px solid #999;
        padding: 0;
        font-weight: bold;
        font-size: 16px;
        text-align: center;
        line-height: 30px;
        cursor: pointer;
        user-select: none;
      }
      
      .cell.black {
        background-color: black;
        color: white;
      }
      
      .cell.grey {
        background-color: grey;
        color: black;
      }
      
      .cell.white {
        background-color: white;
        color: black;
      }
      
      .cell.error {
        color: red;
      }
    </style>

  </head>
  <body>
    <h1>Colour</h1>

    <table id="grid">
      <!-- JS will generate rows and cells -->
    </table>

    <div>
      <p id="feedback"></p>
    </div>

    <div>
      <button id="resetBtn">Start a new game</button>
    </div>

    <label
      >Grid size:
      <input type="number" id="gridSizeInput" value="10" min="5" max="20" />
    </label>

    <button id="applyBtn">Apply</button>

<script>

// ==== NAMING RULES ====
// cellElement → DOM cell (what the player sees)
// boardData   → logical cell (what the game knows)
// Keep them separate!


// ==== GLOBALs + CONSTANTS ====

let gridSize = 10; // start with 10, easier to adjust later
let blackCell = Math.floor(Math.random() * 11) + 40;
// let firstClick = true;
let board = [];
let grid = [];
let gameOver = false;
let sectorSize = Math.max(3, Math.floor(gridSize / 3)) // dynamic sector size
let errorCells = new Set(); // if error, errorCells.add("1,5") .delete .has .... use string.
let anchorCount = 0;

// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
//  generateBoard(gridSize);
  generateValidBoard();
  
 generateGrid();
  attachListeners();
}

// visible GRID
function generateGrid() {
  grid = [];
  for (let gridRow = 0; gridRow < gridSize; gridRow++) {
    let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < gridSize; gridCol++) {
      let td = document.createElement("td");
      td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  }
}

// create clear logic BOARD (the invisible one BTS)
function generateBoard(gridSize) {
  board = [];
  for (let row = 0; row < gridSize; row++) {
    let rowData = [];
    for (let col = 0; col < gridSize; col++) {
      rowData.push({
        colour: "grey", // original state
        state: "hidden", // can become "flagged" / "error"
        adjacent: 0, // use this for the number shown on the cell
        isBlack: false, // determines if cell is black or white
        displayed: true,
        isAnchor: false,
        sectorID: Math.floor(row / sectorSize) + "-" + Math.floor(col / sectorSize)
      });
    }
    board.push(rowData);
  }
}

// create the blackcells. put within checkanswer
function generateCells() {
  let blackNumber = 0;
  let col = 0;
  let row = 0;

  while (blackNumber < blackCell) {
    col = Math.floor(Math.random() * gridSize);
    row = Math.floor(Math.random() * gridSize);
    if (board[row][col].isBlack == true) continue;

    board[row][col].isBlack = true; // set the signal flag
    blackNumber++;
  }

  // count adjacent once all signal placed
  // For each cell, loop through its neighbors
  // If neighbor is in bounds and has a signal, increment adjacent count
  let boardCol = 0;
  let boardRow = 0;

  for (boardRow = 0; boardRow < gridSize; boardRow++) {
    for (boardCol = 0; boardCol < gridSize; boardCol++) {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          let neighbourRow = boardRow + dr;
          let neighbourCol = boardCol + dc;

          if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
          if (neighbourCol < 0 || neighbourCol >= gridSize) continue;

          if (board[neighbourRow][neighbourCol].isBlack == true) {
            if (isAdjacent(neighbourRow, neighbourCol, boardRow, boardCol)) {
              board[boardRow][boardCol].adjacent++;
}}}
              if (board[boardRow][boardCol].displayed) {
                let cellElement = document.getElementById(
                  `cell-${boardRow}-${boardCol}`
                );
              
	cellElement.textContent = String(board[boardRow][boardCol].adjacent);

        }
      }
    }}}


function generateValidBoard() {
  let attempts = 0;
  let maxAttempts = 10;
  do {

    generateBoard(gridSize); // empty board
    generateCells(); // fill logic
 
    attempts++;
    if (attempts > maxAttempts) {
      console.error("Too many retries, stopping.");
      break;
    }
  } while (!checkAnchor());
}

function checkAnchor() {
let anchors = calcAnchorCount(board, gridSize)
return validAnchorCount(anchors, gridSize)
}


function calcAnchorCount(board, gridSize) {
let anchorCount = 0;
for (row = 0; row < gridSize; row++) {
    for (col= 0; col < gridSize; col++) {
let boardData = board[row][col]
if (boardData.adjacent == 0 || boardData.adjacent == 9) { anchorCount++ }
if (row == 0 || row == gridSize - 1 || col == 0 || col == gridSize - 1) {
if (boardData.adjacent == 6) { anchorCount += .8 }
}
if ((row == 0 || row == gridSize - 1) && (col == 0 || col == gridSize - 1)) {
if (boardData.adjacent == 4) { anchorCount += 0.6 }
} else if (boardData.adjacent == 8 || boardData.adjacent == 1) { anchorCount += 0.2 }
}}
return anchorCount;
}

function validAnchorCount(anchorCount, gridSize) { // just for determining min/max. no calcs
let minAnchor = gridSize * gridSize * 0.08
let maxAnchor = gridSize * gridSize * 0.12
return anchorCount > minAnchor && anchorCount < maxAnchor
}



function isAdjacent(r, c, clickedRow, clickedCol) {
  // check how far apart is 2 cells (mainly for generating clear area around the first click)
  return Math.abs(r - clickedRow) <= 1 && Math.abs(c - clickedCol) <= 1;
}


// ==== GAME LOGIC ====

function countImmediate(clickedRow, clickedCol) {
 let boardData = board[clickedRow][clickedCol];
  let blackCount = 0;
  let whiteCount = 0;
  let cellCount = 0;
for (let r = clickedRow - 1; r <= clickedRow + 1; r++) {
    for (let c = clickedCol - 1; c <= clickedCol + 1; c++) {
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) continue;
  cellCount++;
let nData = board[r][c]
if (nData.colour == "black") { blackCount++ }
else if (nData.colour == "white") { whiteCount++ }
}}
return { blackCount, whiteCount, cellCount }}

function checkImmediate(clickedRow, clickedCol) {
let { blackCount, whiteCount, cellCount } = countImmediate(clickedRow, clickedCol)
let boardData = board[clickedRow][clickedCol];
if (!boardData.displayed) return;
let isError = blackCount > boardData.adjacent ||
              whiteCount > cellCount - boardData.adjacent
let cellElement = document.getElementById(`cell-${clickedRow}-${clickedCol}`);
let coords = `${clickedRow},${clickedCol}`;
if (isError) {
	cellElement.classList.add("error");
        errorCells.add(coords);
      } else if (!isError) {
        cellElement.classList.remove("error");
        errorCells.delete(coords);
}}

function updateArea(clickedRow, clickedCol) { // not accurate. 
for (let r = clickedRow - 2; r <= clickedRow + 2; r++) {
    for (let c = clickedCol - 2; c <= clickedCol + 2; c++) {
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) continue;
if (!board[r] || !board[r][c]) continue; // just in case it checks outside 
checkImmediate(r, c)
}}}

function checkWin() {
  if (errorCells.size > 0) return;
  let correctTile = 0;
  let incorrectTile = 0;
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      let cellData = board[r][c];
    if (cellData.state == "hidden") return;  
        if (cellData.isBlack && cellData.colour == "black") {
          correctTile++;
        } else if (cellData.isBlack && cellData.colour != "black") {
          incorrectTile++;
      }
    }
  }
  if (correctTile == blackCell && incorrectTile == 0) {
    gameOver = true;
    triggerGameOver();
    document.getElementById("feedback").textContent = "You win! Good job.";
  }
}

function resetGame(newSize = gridSize) {
  gridSize = newSize;
  document.getElementById("feedback").textContent = "";
  board = [];
  generateBoard(gridSize);
  document.getElementById("grid").innerHTML = "";
  generateGrid(gridSize);
  generateCells();
  gameOver = false;
  errorCells = new Set();
  attachListeners();
}

// ==== UI + INTERACTION ====

function handleCellClick(e) {
  // left click turns it BLACK, even from white
  let clickedCell = e.target;
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  let boardData = board[clickedRow][clickedCol];
  if (gameOver) return;
  if (boardData.state == "hidden" || boardData.colour == "white") {
    boardData.state = "revealed";
    boardData.colour = "black";
    clickedCell.classList.remove("grey", "white");
    clickedCell.classList.add("black");
   updateArea(clickedRow, clickedCol);
    checkWin();
  } else if (boardData.state == "revealed" && boardData.colour == "black") {
    boardData.state = "hidden";
    boardData.colour = "grey";
    clickedCell.classList.remove("black");
    clickedCell.classList.add("grey");
 updateArea(clickedRow, clickedCol);
  }
}

function toggleWhite(e) {
  // right click turns it WHITE
  if (gameOver) return;
  let clickedCell = e.target;
  e.preventDefault();
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  let boardData = board[clickedRow][clickedCol];

  if (boardData.state == "hidden" || boardData.colour == "black") {
    boardData.state = "revealed";
    boardData.colour = "white";
    clickedCell.classList.remove("grey", "black");
    clickedCell.classList.add("white");
  updateArea(clickedRow, clickedCol);
    checkWin();
  } else if (boardData.state == "revealed" && boardData.colour == "white") {
    boardData.state = "hidden";
    boardData.colour = "grey";
    clickedCell.classList.remove("white");
    clickedCell.classList.add("grey");
updateArea(clickedRow, clickedCol);
  }
}

function triggerGameOver() { // disableInputs
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.addEventListener("click", handleCellClick); // left click
  });
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleWhite); // right click
  });
  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame(gridSize);
  });
  document.getElementById("applyBtn").addEventListener("click", customise);

  // phone long tap
  cells.forEach((cell) => {
    let pressTimer;
    let longPressTriggered = false;

    cell.addEventListener("touchstart", (e) => {
      e.preventDefault();
      longPressTriggered = false;
      pressTimer = setTimeout(() => {
        toggleWhite(e);
        longPressTriggered = true;
      }, 600); // long press
    });

    cell.addEventListener("touchend", (e) => {
      clearTimeout(pressTimer);
      if (!longPressTriggered) {
        handleCellClick(e); // treat as single tap
      }
    });
  });
}

function customise() {
  let inputSize = document.getElementById("gridSizeInput").value;
  let newSize = gridSize;
  if (inputSize !== "") {
    newSize = parseInt(inputSize);
  }
  resetGame(newSize);
}



// ==== BOARD VALIDATION ====

// let solutionCount = 0;

// check for solution. when complete, check for another solution. if only 1 == unique, if 2, undo the hide, and return



</script>

</body>
</html>
