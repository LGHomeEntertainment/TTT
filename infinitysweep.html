<!DOCTYPE html>
<!-- To Infinity and Beyond! in chunks -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SS</title>

  <style>
/* Container for the grid */
#grid {
  display: grid;
  border-collapse: collapse;
  border-spacing: 0;
  grid-template-columns: repeat(var(--grid-size), 1fr); /* dynamic columns */
  width: fit-content;
  margin: 20px auto;
}

/* Each cell */
.cell {
  position: relative;
  width: 30px;
  height: 30px;
  background-color: lightgray;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

/* Revealed cell */
.cell.revealed {
  background-color: lightblue;
  cursor: default;
}

/* Mine cell */
.cell.mine {
  color: white;
}

.cell.fatal-mine {
background-color: red;
}

/* Flagged cell */
.cell.flagged {
  background-color: orange;
  color: white;
}

/* Wrong Flag */
.wrong-flag::after {
content: "âœ•";
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
  color: blue;
  font-size: 20px;

}

  /* Hint cell */
.hint {
  outline: 3px solid yellow;
  animation: pulse 0.4s infinite alternate;
}

@keyframes pulse {
  from { transform: scale(1); }
  to { transform: scale(1.1); }
}
    
</style>

</head>
<body>

<h1>SS</h1>

<table id="grid">
  <!-- JS will generate rows and cells -->
</table>


<div> 
  <p id="feedback"></p>
</div>

<div> 
  <button id="hintBtn">Hint</button>
  <button id="resetBtn">Start a new game</button>
</div>

<label>Grid size:
<input type="number" id="sizeInput" value="10" min="5" max="20">
</label>
<label>Mines:
  <input type="number" id="mineInput" value="10" min="1" max="100">
</label>
<button id="applyBtn">Apply</button>



<script>

// ==== GLOBALs + CONSTANTS ====

let size = 10; // start with 10, easier to adjust later
let totalMines = 10;
let firstClick = true;
let board = new Map();
let grid = [];
let gameOver = false;

// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
  document.getElementById("grid").innerHTML = "";
  generateGrid(size);
//  generateBoard(size);
//  populateNeighbours();
  attachListeners();
}

// visible GRID
function generateGrid(size) {
  grid = [];
  for (let gridRow = 0; gridRow < size; gridRow++) {
    let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < size; gridCol++) {
      let td = document.createElement("td");
      td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  }
}

function populateNeighbours() {
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      getCell(r, c).neighbours = getNeighbourCoords(r, c);
    }
  }
  console.log(getCell(0, 0).neighbours);
}
// now each cell knows its neighbours, and can check the specific 8 immediately instead of looking through the whole board

// create the MINES. put within checkanswer
function generateMines(clickedRow, clickedCol, newMines = totalMines) {
  totalMines = newMines;

// RESET everything first. *in case* validate board regenerates board due to unsolvability.
for (let r = 0; r < size; r++) {
for (let c = 0; c < size; c++) {
getCell(r, c).mine = false
getCell(r, c).adjacent = 0
}}

// then place mines
  let minesNumber = 0;
  let mineCol = 0;
  let mineRow = 0;

  while (minesNumber < totalMines) {
    mineCol = Math.floor(Math.random() * size);
    mineRow = Math.floor(Math.random() * size);
    if (mineCol == clickedCol && mineRow == clickedRow) continue;
    if (getCell(mineRow, mineCol).mine == true ||
      isAdjacent(mineRow, mineCol, clickedRow, clickedCol) // if mine or if is adjacent to the cell
    )
      continue; // skip!

    getCell(mineRow, mineCol).mine = true; // set the mine flag
    minesNumber++;
  }
  console.log("mines placed");

  // count adjacent once all mines placed
  // For each cell, loop through its 8 neighbors
  // If neighbor is in bounds and has a mine, increment adjacent count

  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      let cell = getCell(r, c);
      let count = 0;
      for (let [nr, nc] of cell.neighbours) {
        if (getCell(nr, nc).mine) count++;
      }
      cell.adjacent = count;
    }
  }
  console.log("adjacent count completed");
}

// ==== GAME LOGIC ====

function handleClicks(r, c, cellEl) {
 if (gameOver) return;
console.log(board instanceof Map)
let cell = getCell(r, c)

if (cell.revealed == false) {
  checkAnswer(r, c, cellEl);
} else {
  chordCell(r, c);
}
}

function checkAnswer(clickedRow, clickedCol, clickedCell) {
//  let clickedCell = e.target;
//  let clickedRow = parseInt(clickedCell.dataset.row);
//  let clickedCol = parseInt(clickedCell.dataset.col);
//  if (gameOver) return;
  if (firstClick) {
    firstClick = false;
    revealCell(clickedRow, clickedCol, clickedCell);
  } else {
    revealCell(clickedRow, clickedCol, clickedCell);
   // checkWin();
  }
}

function revealCell(r, c, cellEl) {
ensureCell(r, c)
  let cell = getCell(r, c);

  if (cell.revealed || cell.flagged) return;

// Rule 1: revealed cell is always safe
if (cell.mine == null) {
  cell.mine == false
  cell.generated = true
  }

  cell.revealed = true;
  cellEl.classList.add("revealed");


cell.adjacent = computeAdjacent(r, c)
propagateFrom (r, c)

  if (cell.adjacent > 0) {
    cellEl.textContent = cell.adjacent;
    return;
  }

  for (let [nr, nc] of cell.neighbours) {
    if (getCell(nr, nc).flagged) continue;

    let neighbourCell = document.getElementById(`cell-${nr}-${nc}`);
    revealCell(nr, nc, neighbourCell); // CASCADE!!
  }
}

function chordCell(clickedRow, clickedCol) {
let cell = getCell(clickedRow, clickedCol);
if (!cell.revealed || cell.adjacent == 0) return;
let flagged = 0
let hidden = []
for (let [nr, nc] of cell.neighbours) {
if (getCell(nr, nc).flagged) flagged++;
else if (!getCell(nr, nc).revealed) hidden.push([nr, nc])
}
if (flagged == cell.adjacent) {
hidden.forEach(([nr, nc]) => {
revealCell(nr, nc, document.getElementById(`cell-${nr}-${nc}`))
})
}}



function triggerGameOver(deadRow, deadCol) {
gameOver = true
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      let cell = getCell(r, c);
      let cellEl = document.getElementById(`cell-${r}-${c}`);

// mine but not flagged
      if (cell.mine && !cell.flagged) {
//        cell.revealed = true;
//        cellEl.classList.add("mine");
        cellEl.textContent = "ðŸ’£"; 
      }

// flagged but not mine. aka wrong flag
      if (!cell.mine && cell.flagged) {
//        cell.revealed = true;
        cellEl.classList.add("wrong-flag");
        cellEl.textContent = "ðŸš©"; 
      }

// correctly flagged mine
cell.revealed = true

    }
  }
}

function resetGame(newSize = size, newMines = totalMines) {
  size = newSize;
  totalMines = newMines;
  document.getElementById("feedback").textContent = "";
  board.clear();
//  generateBoard(size);
//  populateNeighbours();
  document.getElementById("grid").innerHTML = "";
  generateGrid(size);
  firstClick = true;
  gameOver = false;
  attachListeners();
}

function isAdjacent(r, c, clickedRow, clickedCol) {
  // check how far apart is 2 cells (for generating mines)
  return Math.abs(r - clickedRow) <= 1 && Math.abs(c - clickedCol) <= 1;
}

function toggleFlag(e) {
  if (gameOver) return;
  let clickedCell = e.target;
  e.preventDefault();
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  if (getCell(clickedRow, clickedCol).revealed == true) {
    return;
  } else if (getCell(clickedRow, clickedCol).flagged) {
    getCell(clickedRow, clickedCol).flagged = false;
    clickedCell.textContent = ""; // no flag
    clickedCell.classList.remove("flagged");
  } else {
    getCell(clickedRow, clickedCol).flagged = true;
    clickedCell.textContent = "ðŸš©"; // add flag
    clickedCell.classList.add("flagged");
  }
}


// ==== HINT SYSTEM ====

function revealHint() {
  let move = findGuaranteedMove();
  if (!move) {
document.getElementById("feedback").textContent =
      "No guaranteed safe move.";
return
}
    highlightCell(move.r, move.c);
}

function findGuaranteedMove() { 
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      let cell = getCell(r, c);

      if (!cell.revealed || cell.adjacent == 0) continue;

let hidden = []
let flagged = 0

      for (let [nr, nc] of cell.neighbours) {
       let n = getCell(nr, nc)
if (n.flagged) flagged++
else if (!n.revealed) hidden.push([nr, nc])
}

if (hidden.length == 0) continue

// guaranteed safe
if (flagged == cell.adjacent) {
return {
r: hidden[0][0],
c: hidden[0][1],
type: "safe"
}}

// guaranteed mine
if (flagged + hidden.length == cell.adjacent) {
return {
r: hidden[0][0],
c: hidden[0][1],
type: "mine"
}}}}
return null // no forced move
}



function getNeighbourCoords(r, c) {
  let neighbours = [];

  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr == 0 && dc == 0) continue;
      let neighbourRow = r + dr;
      let neighbourCol = c + dc;
      if (neighbourRow < 0 || neighbourRow >= size) continue;
      if (neighbourCol < 0 || neighbourCol >= size) continue;

      neighbours.push([neighbourRow, neighbourCol]);
    }
  }
  return neighbours;
}

function highlightCell(r, c) {
  let cellElement = document.getElementById(`cell-${r}-${c}`);
  cellElement.classList.add("hint");

  // Remove highlight after short delay
  setTimeout(() => {
    cellElement.classList.remove("hint");
  }, 1500);
}

// ==== UI + INTERACTION ====

function disableInputs() {
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.addEventListener("click", onClick); // left click
  });
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleFlag); // right click
  });
  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame(size, totalMines);
  });
  document.getElementById("hintBtn").addEventListener("click", () => {
    revealHint();
  });
  document.getElementById("applyBtn").addEventListener("click", customise);

  // phone long tap
  cells.forEach((cell) => {
    let pressTimer;
    let longPressTriggered = false;

    cell.addEventListener("touchstart", (e) => {
      e.preventDefault();
      longPressTriggered = false;
      pressTimer = setTimeout(() => {
        toggleFlag(e);
        longPressTriggered = true;
      }, 600); // long press
    });

    cell.addEventListener("touchend", (e) => {
      clearTimeout(pressTimer);
      if (!longPressTriggered) {
        let r = parseInt(cell.dataset.row);
        let c = parseInt(cell.dataset.col);
        let cellData = getCell(r, c);
    
handleClicks(r, c, cell);
      }
    });
  });
}

function onClick(e) {
if (!e.target.classList.contains("cell")) return;
let cellEl = e.target;
  let clickedRow = parseInt(cellEl.dataset.row);
  let clickedCol = parseInt(cellEl.dataset.col);
handleClicks(clickedRow, clickedCol, cellEl);
}

function customise() {
  let inputSize = document.getElementById("sizeInput").value;
  let inputMine = document.getElementById("mineInput").value;

  let newSize = size;
  let newMines = totalMines;

  if (inputSize !== "") {
    newSize = parseInt(inputSize);
  }
  if (inputMine !== "") {
    newMines = parseInt(inputMine);
  }
  resetGame(newSize, newMines);
}



// ==== BOARD VALIDATION ====



// Step 5: Retry logic (outside this function)
// If validateBoard() returns false, regenerate mines and try again
// already put in generateMines(), after first click

function cloneBoard(board) {
  let testBoard = [];
  for (let row = 0; row < size; row++) {
    let rowTest = [];
    for (let col = 0; col < size; col++) {
      rowTest.push({ ...getCell(row, col) });
    }
    testBoard.push(rowTest);
  }
  return testBoard; // only by returning, we can access it in the validate board (). it's not really global though
}

function cascadeReveal(clickedRow, clickedCol, testBoard, revealedMap) {
  if (revealedMap[clickedRow][clickedCol]) return;
  revealedMap[clickedRow][clickedCol] = true;
  if (testBoard[clickedRow][clickedCol].adjacent > 0) return;
  for (let [nr, nc] of testBoard[clickedRow][clickedCol].neighbours) {
    cascadeReveal(nr, nc, testBoard, revealedMap); // CASCADE!!
  }
}

// ==== INFINITY ====

function key(r, c) {
return `${r},${c}`;
}

function getCell(r, c) {
let k = key(r, c)
return board.get(k) || null;
}

function ensureCell(r, c) {
let k = key(r, c)
if (!board.has(k)) {
board.set(k, createEmptyCell(r, c))
}}

function ensureNeighbours(r, c) {
for (let [nr, nc] of getNeighbourCoords(r, c)) {
ensureCell(nr, nc)
}}

function createEmptyCell(r, c) {
return {
r, 
c, 
mine: null, // null/true/false
revealed: false, 
// number: null,
adjacent: null,
flagged: false,
neighbours: getNeighbourCoords(r, c),

committed: false, // mine is final
generated: false // whether mine has been decided
}; }

function countNeighbourState(r, c) {
let mines = 0
let undecided = 0

for (let [nr, nc] of getNeighbourCoords(r, c)) {
let n = getCell(nr, nc)
if (!n) continue

if (n.mine == true) mines++
else if (n.mine == null) undecided++
}
return { mines, undecided }
}

function decideCell(r, c) {
ensureCell(r, c)
let cell = getCell(r, c)

if (cell.generated) return cell.mine

// check constraints from neighbours
for (let [nr, nc] of cell.neighbours) {
let neighbour = getCell(nr, nc)
if (!neighbour) continue
if (!neighbour.revealed) continue
if (neighbour.adjacent == null) continue

let { mines, undecided } = countNeighbourState(nr, nc)
let remaining = neighbour.adjacent - mines

// if all remaining must be mines --> forced mine
if (remaining == undecided && undecided > 0) {
cell.mine = true;
cell.generated = true
// cell.committed = true
return true
}}

// otherwise stay undecided
// cell.mine = Math.random() < 0.15 // adjustable density
// cell.generated = true
// cell.committed = true
return null
}

function computeAdjacent(r, c) {
// can check and commit. CANNOT CHANGE numbers
let cell = getCell(r, c)
if (cell.adjacent != null) return cell.adjacent

ensureNeighbours(r, c) 

let count = 0

for (let [nr, nc] of cell.neighbours) {
let n = getCell(nr, nc)

if (n.mine == true) count ++
}
  
cell.adjacent = count
return count
}

function propagateFrom(r, c) {
let cell = getCell(r, c)
if (!cell.revealed) return
if (cell.adjacent == null) return

let mines = 0
let undecided = []

for (let [nr, nc] of cell.neighbours) {
let n = getCell(nr, nc)
if (!n) continue

if (n.mine == true) mines++
else if (n.mine == null) undecided.push(n)
}
let remaining = cell.adjacent - mines
if (remaining < 0) return

// Rule 1: all remaining are mines
if (remaining == undecided.length && remaining > 0) {
undecided.forEach(n => {
n.mine = true
n.generated = true
n.committed = true
})}

// Rule 2: all remaining safe
if (remaining == 0 && undecided.length > 0) {
undecided.forEach(n => {
n.mine = false
n.generated = true
n.committed = true
})}
}



// ==== PREVENT BREAKAGE ====
function assertNeverIndexBoard() {
throw new Error("do not index board[r][c]. Use getCell()")
}

board[0] = assertNeverIndexBoard


</script>

</body>
</html>
