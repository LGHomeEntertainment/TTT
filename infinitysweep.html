<!doctype html>
<!-- The Broken Frontier -->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Infinity SS</title>
<style>
    body {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  margin: 0;
  padding-top: 20px;
  font-family: sans-serif;
}

#game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

#viewport {
  width: 430px;
  height: 430px;
  overflow: hidden;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
}

#grid {
  display: grid;
  grid-template-columns: repeat(var(--grid-size), 1fr); /* dynamic columns */
  width: fit-content;
}

.controls {
  margin-top: 10px;
  display: flex;
  gap: 10px;
}

/* Each cell */
.cell {
  position: relative;
  width: 30px;
  height: 30px;
  background-color: lightgray;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

/* Revealed cell */
.cell.revealed {
  background-color: lightblue;
  cursor: default;
}

/* Mine cell */
.cell.mine {
  color: white;
}

.cell.fatal-mine {
  background-color: red;
}

/* Flagged cell */
.cell.flagged {
  background-color: orange;
  color: white;
}

/* Wrong Flag */
.wrong-flag::after {
  content: "âœ•";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: blue;
  font-size: 20px;
}
  </style>
  </head>
  <body>
    <div id="game-container">
      <h1>SS</h1>

      <div id="viewport">
        <div id="grid">
          <!-- JS will generate rows and cells -->
        </div>

        <div>
<button id="zoomOutBtn">-</button>
<button id="zoomInBtn">+</button>
          <p id="feedback"></p>
          <p id="revealed">Revealed:</p>
          <p id="deaths">Dead cells:</p>
          <p id="integrity">Integrity:</p>
          <button id="resetBtn">Start a new game</button>
        </div>
      </div>
    </div>

    <script>
      // ==== GLOBALs + CONSTANTS ====

// ==== GLOBALs + CONSTANTS ====

let viewSize = 12;
let cellSize = 30;
let firstClick = true;
let board = new Map();
let grid = [];
let gameOver = false;
let cameraR = 0;
let cameraC = 0;
let startX = 0;
let startY = 0;
let touchMoved = false;
let touchTimer = null;
let isCameraMode = false;

let dragAccumX = 0;
let dragAccumY = 0; // so that not every small movement will cause camera to move

let deathCount = 0;
let revealedCount = 0;


// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
  document.getElementById("grid").innerHTML = "";
  loadGame();
  generateGrid(viewSize);
  attachListeners();
  renderCamera();
}

// visible GRID
function generateGrid(size) {
  let gridEl = document.getElementById("grid");
  gridEl.innerHTML = "";

  for (let gridRow = 0; gridRow < size; gridRow++) {
    // let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < size; gridCol++) {
      let cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = gridRow;
      cell.dataset.col = gridCol;
      gridEl.appendChild(cell);
    }
  }
  gridEl.style.setProperty("--grid-size", size);
}

// ==== GAME LOGIC ====
function revealCell(r, c) {
  ensureCell(r, c);
  let cell = getCell(r, c);
  if (cell.revealed || cell.flagged) return;

  // if still undecided, then just guarantee safe
  if (cell.mine == null) {
    cell.mine = false;
    cell.generated = true;
  }

  cell.revealed = true;
  revealedCount++;
  updateStats();

  if (cell.mine == true) {
    registerDeath(cell);
  }

  if (!firstClick) {
 //   resolveEntropy(cell);
  }

  cell.adjacent = computeAdjacent(r, c);
  propagateFrom(r, c);

  firstClick = false;

  // cascade
  if (cell.adjacent == 0) {
    for (let [nr, nc] of cell.neighbours) {
      revealCell(nr, nc);
    }
  }
  saveGame();
}

function toggleFlag(sr, sc) {
  let wr = cameraR + sr;
  let wc = cameraC + sc;

  let cell = getCell(wr, wc);
  if (cell.revealed) return;

  cell.flagged = !cell.flagged;
  renderCamera();
  saveGame();
}

function chordCell(r, c) {
  let cell = getCell(r, c);

  if (!cell.revealed || cell.adjacent == 0 || cell.adjacent == null) return;

  let flagged = 0;
  let hidden = [];

  for (let [nr, nc] of cell.neighbours) {
    let n = getCell(nr, nc);

    if (n.flagged || (n.mine && n.revealed)) flagged++;
    else if (!n.revealed) hidden.push([nr, nc]);
  }
  if (flagged == cell.adjacent) {
    hidden.forEach(([nr, nc]) => {
      revealCell(nr, nc);
    });
  }
}

function resetGame() {
  document.getElementById("feedback").textContent = "";
  document.getElementById("revealed").textContent = "Revealed:";
  document.getElementById("deaths").textContent = "Dead cells:";
  document.getElementById("integrity").textContent = "Integrity:";
  deathCount = 0;
  revealedCount = 0;
  board.clear();
cameraR = 0
cameraC = 0
dragAccumX = 0 
dragAccumY = 0
startX = 0;
startY = 0;
touchMoved = false;
touchTimer = null;
isCameraMode = false;

  document.getElementById("grid").innerHTML = "";
  generateGrid(viewSize);
  firstClick = true;
  gameOver = false;
  attachListeners();
renderCamera()
}

function registerDeath(cell) {
  if (cell.dead) return; // prevent double count
  cell.dead = true;
  deathCount++;
  updateStats();
}

function updateStats() {
  let integrity = 100;

  if (revealedCount > 0) {
    integrity = Math.floor((1 - deathCount / revealedCount) * 100);
  }
  document.getElementById("revealed").textContent =
    `Revealed: ${revealedCount}`;
  document.getElementById("deaths").textContent = `Dead cells: ${deathCount}`;
  document.getElementById("integrity").textContent = `Integrity: ${integrity}%`;
}

function getNeighbourCoords(r, c) {
  let neighbours = [];

  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr == 0 && dc == 0) continue;

      neighbours.push([r + dr, c + dc]);
    }
  }
  return neighbours;
}

// ==== UI + INTERACTION ====
function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll(".cell");

  // Left click
  cells.forEach((cell) => {
    cell.addEventListener("click", onClick);
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame();
  });

  document.getElementById("zoomOutBtn").addEventListener("click", () => {
viewSize += 2
generateGrid(viewSize)
renderCamera()
  });

  document.getElementById("zoomInBtn").addEventListener("click", () => {
viewSize = Math.max(6, viewSize - 2)
generateGrid(viewSize)
renderCamera()
  });

  // Right click
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      let sr = parseInt(cell.dataset.row);
      let sc = parseInt(cell.dataset.col);

      toggleFlag(sr, sc);
    });
  });

  // Grid movement (for mobile camera)
  let grid = document.getElementById("grid");

  // touchstart
  grid.addEventListener(
    "touchstart",
    (e) => {
      if (e.touches.length == 2) {
        // camera mode
        isCameraMode = true;
        touchMoved = false;

        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;

        return;
      }

      if (e.touches.length == 1) {
        isCameraMode = false;
        touchMoved = false;

        let touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;

        // long press = flag
        touchTimer = setTimeout(() => {
          let cell = getCellFromScreen(touch.clientX, touch.clientY);
          if (cell) {
            toggleFlag(cell.r, cell.c);
          }
        }, 450);
      }
    },
    { passive: false },
  );

  // touchmove
  grid.addEventListener(
    "touchmove",
    (e) => {
      touchMoved = true;

      if (touchTimer) {
        clearTimeout(touchTimer);
        touchTimer = null;
      }

      // Only 2 fingers move camera
      if (isCameraMode && e.touches.length == 2) {
        let dx = e.touches[0].clientX - startX;
        let dy = e.touches[0].clientY - startY;

        moveCamera(dx, dy);

        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      }

      e.preventDefault();
    },
    { passive: false },
  );

  // touchend
  grid.addEventListener(
    "touchend",
    (e) => {
      if (touchTimer) {
        clearTimeout(touchTimer);
        touchTimer = null;
      }

      // single tap --> reveal
      if (!touchMoved && !isCameraMode) {
        let touch = e.changedTouches[0];
        let cell = getCellFromScreen(touch.clientX, touch.clientY);

        if (cell) {
          revealCell(cell.r, cell.c);
        }
      }
      isCameraMode = false;
    },
    { passive: false },
  );

  // Camera movement
  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp" || e.key === "w") cameraR--;
    if (e.key === "ArrowDown" || e.key === "s") cameraR++;
    if (e.key === "ArrowLeft" || e.key === "a") cameraC--;
    if (e.key === "ArrowRight" || e.key === "d") cameraC++;

    renderCamera();
  });
}

function onClick(e) {
  let sr = parseInt(e.target.dataset.row);
  let sc = parseInt(e.target.dataset.col);

  let wr = cameraR + sr;
  let wc = cameraC + sc;
  let cell = getCell(wr, wc);
  if (cell.revealed) {
    chordCell(wr, wc);
  } else {
    revealCell(wr, wc);
  }
  renderCamera();
}

function getCellFromScreen(x, y) {
  let el = document.getElementFromPoint(x, y);
  if (!el || !el.classList.contains("cell")) return null;

  let sr = parseInt(el.dataset.row);
  let sc = parseInt(el.dataset.col);
  let wr = cameraR + sr;
  let wc = cameraC + sc;

  return getCell(wr, wc);
}

// ==== INFINITY ====

function key(r, c) {
  return `${r},${c}`;
}

function getCell(r, c) {
  ensureCell(r, c);
  return board.get(key(r, c));
}

function ensureCell(r, c) {
  let k = key(r, c);
  if (!board.has(k)) {
    board.set(k, createEmptyCell(r, c));
  }
}

function ensureNeighbours(r, c) {
  for (let [nr, nc] of getNeighbourCoords(r, c)) {
    ensureCell(nr, nc);
  }
}

function createEmptyCell(r, c) {
  return {
    r,
    c,
    mine: null, // null/true/false
    revealed: false,
    adjacent: null,
    flagged: false,
    neighbours: getNeighbourCoords(r, c),
    dead: false,
    committed: false, // mine is final
    generated: false, // whether mine has been decided
  };
}

function countNeighbourState(r, c) {
  let mines = 0;
  let undecided = 0;

  for (let [nr, nc] of getNeighbourCoords(r, c)) {
    let n = getCell(nr, nc);
    if (!n) continue;

    if (n.mine == true) mines++;
    else if (n.mine == null) undecided++;
  }
  return { mines, undecided };
}

function decideCell(r, c) {
  ensureCell(r, c);
  let cell = getCell(r, c);

  if (cell.generated) return cell.mine;

  // check constraints from neighbours
  for (let [nr, nc] of cell.neighbours) {
    let neighbour = getCell(nr, nc);
    if (!neighbour) continue;
    if (!neighbour.revealed) continue;
    if (neighbour.adjacent == null) continue;

    let { mines, undecided } = countNeighbourState(nr, nc);
    let remaining = neighbour.adjacent - mines;

    // if all remaining must be mines --> forced mine
    if (remaining == undecided && undecided > 0) {
      cell.mine = true;
      cell.generated = true;
      // cell.committed = true
      return true;
    }
  }

  return null;
}

function computeAdjacent(r, c) {
  // can check and commit. CANNOT CHANGE numbers
  let cell = getCell(r, c);
  let count = 0;

  for (let [nr, nc] of cell.neighbours) {
    let n = getCell(nr, nc);

    // ðŸ”¥ force decision if still unknown
    if (n.mine === null) {
      decideCell(nr, nc);
    }

    if (n.mine == true) count++;
  }

  cell.adjacent = count;
  return count;
}

function propagateFrom(r, c) {
  let cell = getCell(r, c);
  if (!cell.revealed) return;
  if (cell.adjacent == null) return;

  let mines = 0;
  let undecided = [];

  for (let [nr, nc] of cell.neighbours) {
    let n = getCell(nr, nc);
    if (!n) continue;

    if (n.mine == true) mines++;
    else if (n.mine == null) undecided.push(n);
  }
  let remaining = cell.adjacent - mines;
  if (remaining < 0) return;

  // Rule 1: all remaining are mines
  if (remaining == undecided.length && remaining > 0) {
    undecided.forEach((n) => {
      n.mine = true;
      n.generated = true;
      n.committed = true;
      propagateFrom(n.r, n.c);
    });
  }

  // Rule 2: all remaining safe
  if (remaining == 0 && undecided.length > 0) {
    undecided.forEach((n) => {
      n.mine = false;
      n.generated = true;
      n.committed = true;
      propagateFrom(n.r, n.c);
    });
  }
}

function resolveEntropy(cell) {
  let undecided = cell.neighbours
    .map(([r, c]) => getCell(r, c))
    .filter((n) => n.mine === null);

  if (undecided.length === 0) return;

  // danger increases as player explores
  let danger = Math.min(revealedCount / 800, 1);
  let mineChance = 0.1 + danger * 0.15;

  for (let n of undecided) {
    if (Math.random() < mineChance) {
      n.mine = true;
      n.generated = true;
      n.committed = true;
    }
  }
}

// ==== CAMERA VIEW ===

function renderCamera() {
  for (let sr = 0; sr < viewSize; sr++) {
    for (let sc = 0; sc < viewSize; sc++) {
      let wr = cameraR + sr;
      let wc = cameraC + sc;

      ensureCell(wr, wc);

      let cell = getCell(wr, wc); // board uses wr/wc
      let el = document.querySelector(
        `.cell[data-row="${sr}"][data-col="${sc}"]`,
      ); // dOM is sr/sc

      if (!el) continue;
      drawCell(el, cell);
    }
  }
}

function drawCell(el, cell) {
  el.className = "cell";
  el.textContent = "";
  el.style.backgroundColor = "";

  if (cell.revealed) {
    el.classList.add("revealed");

    if (cell.mine) {
      cell.dead = true;
      el.textContent = "ðŸ’£";
      el.style.backgroundColor = "red";
    } else if (cell.adjacent > 0) {
      el.textContent = cell.adjacent;
    } else {
      el.textContent = "";
    }
  } else if (cell.flagged) {
    el.textContent = "ðŸš©";
  } else {
    el.textContent = "";
  }
}

function moveCamera(dx, dy) {
//  let cellSize = 30; // (set in css)

  dragAccumX += dx;
  dragAccumY += dy;

  let moveX = Math.trunc(dragAccumX / cellSize);
  let moveY = Math.trunc(dragAccumY / cellSize);

  if (moveX != 0) {
    cameraC -= moveX;
    dragAccumX -= moveX * cellSize;
  }

  if (moveY != 0) {
    cameraR -= moveY;
    dragAccumY -= moveY * cellSize;
  }

  if (moveX != 0 || moveY != 0) {
    renderCamera();
  }
}

// ==== SAVE GAME ====
function saveGame() {
  const data = {
    cells: Array.from(board.entries()),
    revealedCount,
    deathCount,
    firstClick,
  };

  localStorage.setItem("infiniteSweeperSave", JSON.stringify(data));
}

function loadGame() {
  const raw = localStorage.getItem("infiniteSweeperSave");
  if (!raw) return;

  const data = JSON.parse(raw);

  board = new Map(data.cells);
  revealedCount = data.revealedCount;
  deathCount = data.deathCount;
  firstClick = data.firstClick;

  renderCamera();
  updateStats();
}

    </script>
  </body>
</html>
