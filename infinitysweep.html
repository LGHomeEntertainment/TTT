<!DOCTYPE html>
<!-- To Infinity and Beyond! in chunks -->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Infinity SS</title>

    <style>
      /* Container for the grid */
#grid {
  display: grid;
  border-collapse: collapse;
  border-spacing: 0;
  grid-template-columns: repeat(var(--grid-size), 1fr); /* dynamic columns */
  width: fit-content;
  margin: 20px auto;
}

/* Each cell */
.cell {
  position: relative;
  width: 30px;
  height: 30px;
  background-color: lightgray;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

/* Revealed cell */
.cell.revealed {
  background-color: lightblue;
  cursor: default;
}

/* Mine cell */
.cell.mine {
  color: white;
}

.cell.fatal-mine {
  background-color: red;
}

/* Flagged cell */
.cell.flagged {
  background-color: orange;
  color: white;
}

/* Wrong Flag */
.wrong-flag::after {
  content: "âœ•";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: blue;
  font-size: 20px;
}

/* Hint cell */
.hint {
  outline: 3px solid yellow;
  animation: pulse 0.4s infinite alternate;
}

@keyframes pulse {
  from {
    transform: scale(1);
  }
  to {
    transform: scale(1.1);
  }
}
  </style>
  </head>
  <body>
    <h1>SS</h1>

    <table id="grid">
      <!-- JS will generate rows and cells -->
    </table>

    <div>
      <p id="feedback"></p>
    </div>

    <div>
      <button id="hintBtn">Hint</button>
      <button id="resetBtn">Start a new game</button>
    </div>

    <label
      >Grid size:
      <input type="number" id="sizeInput" value="10" min="5" max="20" />
    </label>
    <label
      >Mines:
      <input type="number" id="mineInput" value="10" min="1" max="100" />
    </label>
    <button id="applyBtn">Apply</button>

    <script>
// ==== GLOBALs + CONSTANTS ====

let size = 10;
let firstClick = true;
let board = new Map();
let grid = [];
let gameOver = false;
let viewRow = 0;
let viewCol = 0;
let cameraR = 0
let cameraC = 0

// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
  document.getElementById("grid").innerHTML = "";
  generateGrid(size);
  attachListeners();
}

// visible GRID
function generateGrid(size) {
  grid = [];
  for (let gridRow = 0; gridRow < size; gridRow++) {
    let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < size; gridCol++) {
      let td = document.createElement("td");
      td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  }
}

function populateNeighbours() {
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      getCell(r, c).neighbours = getNeighbourCoords(r, c);
    }
  }
  console.log(getCell(0, 0).neighbours);
}

// ==== GAME LOGIC ====

function handleClicks(r, c, cellEl) {
  if (gameOver) return;
  console.log(board instanceof Map);
  let cell = getCell(r, c);

  if (cell.revealed == false) {
    checkAnswer(r, c, cellEl);
  } else {
    chordCell(r, c);
  }
}

function checkAnswer(clickedRow, clickedCol, clickedCell) {
  revealCell(clickedRow, clickedCol, clickedCell);
}

function revealCell(r, c) {
  ensureCell(r, c);
  ensureNeighbours(r, c);
  let cell = getCell(r, c);
  if (cell.revealed || cell.flagged) return;

  if (cell.mine == true) {
    gameOver = true;

    cellEl.classList.add("fatal-mine");
    cellEl.textContent = "ðŸ’£";

    revealAllMines();
    return;
  }

  // Rule 1: revealed cell is always safe
  if (cell.mine == null) {
    cell.mine = false;
    cell.generated = true;
  }

  cell.revealed = true;
  cellEl.classList.add("revealed");

  if (!firstClick) {
    resolveEntropy(cell);
  }

  cell.adjacent = computeAdjacent(r, c);
  propagateFrom(r, c);

  firstClick = false;

  if (cell.adjacent > 0) {
    cellEl.textContent = cell.adjacent;
    return;
  }

  for (let [nr, nc] of cell.neighbours) {
    let neighbourCell = document.getElementById(`cell-${nr}-${nc}`);
    revealCell(nr, nc, neighbourCell); // CASCADE!!
  }

}

function revealAllMines() {
  for (let cell of board.values()) {
    if (cell.mine == true) {
      let el = document.getElementById(`${cell.r}-${cell.c}`);
      if (!el) continue;

      el.textContent = "ðŸ’£";
      el.classList.add("mine");
    }
  }
}

function chordCell(clickedRow, clickedCol) {
  let cell = getCell(clickedRow, clickedCol);
  if (!cell.revealed || cell.adjacent == 0) return;
  let flagged = 0;
  let hidden = [];
  for (let [nr, nc] of cell.neighbours) {
    if (getCell(nr, nc).flagged) flagged++;
    else if (!getCell(nr, nc).revealed) hidden.push([nr, nc]);
  }
  if (flagged == cell.adjacent) {
    hidden.forEach(([nr, nc]) => {
      revealCell(nr, nc, document.getElementById(`cell-${nr}-${nc}`));
    });
  }
}

function resetGame(newSize = size, newMines = totalMines) {
  size = newSize;
  totalMines = newMines;
  document.getElementById("feedback").textContent = "";
  board.clear();
  //  generateBoard(size);
  //  populateNeighbours();
  document.getElementById("grid").innerHTML = "";
  generateGrid(size);
  firstClick = true;
  gameOver = false;
  attachListeners();
}

function isAdjacent(r, c, clickedRow, clickedCol) {
  // check how far apart is 2 cells (for generating mines)
  return Math.abs(r - clickedRow) <= 1 && Math.abs(c - clickedCol) <= 1;
}

function toggleFlag(e) {
  if (gameOver) return;
  let clickedCell = e.target;
  e.preventDefault();
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  if (getCell(clickedRow, clickedCol).revealed == true) {
    return;
  } else if (getCell(clickedRow, clickedCol).flagged) {
    getCell(clickedRow, clickedCol).flagged = false;
    clickedCell.textContent = ""; // no flag
    clickedCell.classList.remove("flagged");
  } else {
    getCell(clickedRow, clickedCol).flagged = true;
    clickedCell.textContent = "ðŸš©"; // add flag
    clickedCell.classList.add("flagged");
  }
}

// ==== HINT SYSTEM ====
function revealHint() {
  let move = findGuaranteedMove();
  if (!move) {
    document.getElementById("feedback").textContent =
      "No guaranteed safe move.";
    return;
  }
  highlightCell(move.r, move.c);
}

function findGuaranteedMove() {
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      let cell = getCell(r, c);

      if (!cell.revealed || cell.adjacent == 0) continue;

      let hidden = [];
      let flagged = 0;

      for (let [nr, nc] of cell.neighbours) {
        let n = getCell(nr, nc);
        if (n.flagged) flagged++;
        else if (!n.revealed) hidden.push([nr, nc]);
      }

      if (hidden.length == 0) continue;

      // guaranteed safe
      if (flagged == cell.adjacent) {
        return {
          r: hidden[0][0],
          c: hidden[0][1],
          type: "safe",
        };
      }

      // guaranteed mine
      if (flagged + hidden.length == cell.adjacent) {
        return {
          r: hidden[0][0],
          c: hidden[0][1],
          type: "mine",
        };
      }
    }
  }
  return null; // no forced move
}

function getNeighbourCoords(r, c) {
  let neighbours = [];

  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr == 0 && dc == 0) continue;
      let neighbourRow = r + dr;
      let neighbourCol = c + dc;
      if (neighbourRow < 0 || neighbourRow >= size) continue;
      if (neighbourCol < 0 || neighbourCol >= size) continue;

      neighbours.push([neighbourRow, neighbourCol]);
    }
  }
  return neighbours;
}

function highlightCell(r, c) {
  let cellElement = document.getElementById(`cell-${r}-${c}`);
  cellElement.classList.add("hint");

  // Remove highlight after short delay
  setTimeout(() => {
    cellElement.classList.remove("hint");
  }, 1500);
}

// ==== UI + INTERACTION ====
function disableInputs() {
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");

  cells.forEach((cell) => {
    cell.addEventListener("click", onClick); // left click
  });

  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleFlag); // right click
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame(size, totalMines);
  });

  document.getElementById("hintBtn").addEventListener("click", () => {
    revealHint();
  });

  document.getElementById("applyBtn").addEventListener("click", customise);

  cellEl.addEventListener("click", () => {
let wr = cameraR + sr
let wc = cameraC + sc

    revealCell(wr, wc);
renderCamera()
  });

  // phone long tap
  cells.forEach((cell) => {
    let pressTimer;
    let longPressTriggered = false;

    cell.addEventListener("touchstart", (e) => {
      e.preventDefault();
      longPressTriggered = false;
      pressTimer = setTimeout(() => {
        toggleFlag(e);
        longPressTriggered = true;
      }, 600); // long press
    });

    cell.addEventListener("touchend", (e) => {
      clearTimeout(pressTimer);
      if (!longPressTriggered) {
        let r = parseInt(cell.dataset.row);
        let c = parseInt(cell.dataset.col);
        let cellData = getCell(r, c);

        handleClicks(r, c, cell);
      }
    });
  });

  document.addEventListener("keydown", (e) => {
    if (e.key == "ArrowUp") viewRow--;
    if (e.key == "ArrowDown") viewRow++;
    if (e.key == "ArrowLeft") viewCol--;
    if (e.key == "ArrowRight") viewCol++;
    renderView();
  });
}

function onClick(e) {
  if (!e.target.classList.contains("cell")) return;
  let cellEl = e.target;
  let vr = parseInt(cellEl.dataset.row);
  let vc = parseInt(cellEl.dataset.col);
  let { r, c } = viewToWorld(vr, vc);
  handleClicks(r, c, cellEl);
}

function customise() {
  let inputSize = document.getElementById("sizeInput").value;
  let inputMine = document.getElementById("mineInput").value;

  let newSize = size;
  let newMines = totalMines;

  if (inputSize !== "") {
    newSize = parseInt(inputSize);
  }
  if (inputMine !== "") {
    newMines = parseInt(inputMine);
  }
  resetGame(newSize, newMines);
}

// ==== BOARD VALIDATION ====

function cloneBoard(board) {
  let testBoard = [];
  for (let row = 0; row < size; row++) {
    let rowTest = [];
    for (let col = 0; col < size; col++) {
      rowTest.push({ ...getCell(row, col) });
    }
    testBoard.push(rowTest);
  }
  return testBoard; // only by returning, we can access it in the validate board (). it's not really global though
}

function cascadeReveal(clickedRow, clickedCol, testBoard, revealedMap) {
  if (revealedMap[clickedRow][clickedCol]) return;
  revealedMap[clickedRow][clickedCol] = true;
  if (testBoard[clickedRow][clickedCol].adjacent > 0) return;
  for (let [nr, nc] of testBoard[clickedRow][clickedCol].neighbours) {
    cascadeReveal(nr, nc, testBoard, revealedMap); // CASCADE!!
  }
}

// ==== INFINITY ====

function key(r, c) {
  return `${r},${c}`;
}

function getCell(r, c) {
  ensureCell(r, c);
  return board.get(key(r, c));
}

function ensureCell(r, c) {
  let k = key(r, c);
  if (!board.has(k)) {
    board.set(k, createEmptyCell(r, c));
  }
}

function ensureNeighbours(r, c) {
  for (let [nr, nc] of getNeighbourCoords(r, c)) {
    ensureCell(nr, nc);
  }
}

function createEmptyCell(r, c) {
  return {
    r,
    c,
    mine: null, // null/true/false
    revealed: false,
    // number: null,
    adjacent: null,
    flagged: false,
    neighbours: getNeighbourCoords(r, c),

    committed: false, // mine is final
    generated: false, // whether mine has been decided
  };
}

function countNeighbourState(r, c) {
  let mines = 0;
  let undecided = 0;

  for (let [nr, nc] of getNeighbourCoords(r, c)) {
    let n = getCell(nr, nc);
    if (!n) continue;

    if (n.mine == true) mines++;
    else if (n.mine == null) undecided++;
  }
  return { mines, undecided };
}

function decideCell(r, c) {
  ensureCell(r, c);
  let cell = getCell(r, c);

  if (cell.generated) return cell.mine;

  // check constraints from neighbours
  for (let [nr, nc] of cell.neighbours) {
    let neighbour = getCell(nr, nc);
    if (!neighbour) continue;
    if (!neighbour.revealed) continue;
    if (neighbour.adjacent == null) continue;

    let { mines, undecided } = countNeighbourState(nr, nc);
    let remaining = neighbour.adjacent - mines;

    // if all remaining must be mines --> forced mine
    if (remaining == undecided && undecided > 0) {
      cell.mine = true;
      cell.generated = true;
      // cell.committed = true
      return true;
    }
  }

  // otherwise stay undecided
  // cell.mine = Math.random() < 0.15 // adjustable density
  // cell.generated = true
  // cell.committed = true
  return null;
}

function computeAdjacent(r, c) {
  // can check and commit. CANNOT CHANGE numbers
  let cell = getCell(r, c);
  let count = 0;

  for (let [nr, nc] of cell.neighbours) {
    let n = getCell(nr, nc);
    if (n.mine == true) count++;
  }

  cell.adjacent = count;
  return count;
}

function propagateFrom(r, c) {
  let cell = getCell(r, c);
  if (!cell.revealed) return;
  if (cell.adjacent == null) return;

  let mines = 0;
  let undecided = [];

  for (let [nr, nc] of cell.neighbours) {
    let n = getCell(nr, nc);
    if (!n) continue;

    if (n.mine == true) mines++;
    else if (n.mine == null) undecided.push(n);
  }
  let remaining = cell.adjacent - mines;
  if (remaining < 0) return;

  // Rule 1: all remaining are mines
  if (remaining == undecided.length && remaining > 0) {
    undecided.forEach((n) => {
      n.mine = true;
      n.generated = true;
      n.committed = true;
      propagateFrom(n.r, n.c);
    });
  }

  // Rule 2: all remaining safe
  if (remaining == 0 && undecided.length > 0) {
    undecided.forEach((n) => {
      n.mine = false;
      n.generated = true;
      n.committed = true;
      propagateFrom(n.r, n.c);
    });
  }
}

function resolveEntropy(cell) {
  let undecided = cell.neighbours
    .map(([r, c]) => getCell(r, c))
    .filter((n) => n.mine === null);

  if (undecided.length === 0) return;

  // probability scales with openness
  let chance =
    undecided.length >= 6 ? 0.15 : undecided.length >= 4 ? 0.2 : 0.25;

  if (Math.random() < chance) {
    let pick = undecided[Math.floor(Math.random() * undecided.length)];
    pick.mine = true;
    pick.generated = true;
    pick.committed = true;
  }
}

// ==== CAMERA VIEW ====
function viewToWorld(r, c) {
  return {
    r: viewRow + r,
    C: viewCol + c,
  };
}

function renderView() {
  // view changes when camera moves
  for (let vr = 0; vr < size; vr++) {
    for (let vc = 0; vc < size; vc++) {
      let el = document.getElementById(`cell-${vr}-${vc}`);
      let { r, c } = viewToWorld(vr, vc);
      let cell = getCell(r, c);

      el.className = "cell"; // reset visuals
      el.textContent = "";

      if (cell.revealed) {
        el.classList.add("revealed");
      }

      if (cell.mine == true) {
        el.textContent = "ðŸ’£";
      } else if (cell.adjacent > 0) {
        el.textContent = cell.adjacent;
      }

      if (cell.flagged) {
        el.textContent = "ðŸš©";
      }
    }
  }
}

function renderCamera() {
for (let sr = 0; sr < size; sr++) {
for (let sc = 0; sc < size; sc++) {
let wr = cameraR + sr
let wc = cameraC + sc

ensureCell(wr, wc)

let cell = getCell(wr, wc) // board uses wr/wc
let el = document.getElementById(`cell-${sr}-${sc}`) // dOM is sr/sc

drawCell(el, cell)
}}}

function drawCell(el, cell) {
el.className = "cell"

if (cell.revealed) {
el.classList.add("revealed")

if (cell.mine) {
el.textContent = "ðŸ’£";
} else if (cell.adjacent > 0) {
el.textContent = cell.adjacent;
} else { 
el.textContent = ""
}
} else if (cell.flagged) {
el.textContent = "ðŸš©";
} else {
el.textContent = ""
}}


// ==== PREVENT BREAKAGE ====
function assertNeverIndexBoard() {
  throw new Error("do not index board[r][c]. Use getCell()");
}

board[0] = assertNeverIndexBoard;


    </script>
  </body>
</html>
