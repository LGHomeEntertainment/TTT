<!DOCTYPE html>
<!-- To Infinity and Beyond! in chunks -->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Infinity SS</title>

    <style>
      /* Container for the grid */
#grid {
  display: grid;
  border-collapse: collapse;
  border-spacing: 0;
  grid-template-columns: repeat(var(--grid-size), 1fr); /* dynamic columns */
  width: fit-content;
  margin: 20px auto;
touch-action: none;
}

/* Each cell */
.cell {
  position: relative;
  width: 30px;
  height: 30px;
  min-width: 30px;
  min-height: 30px;
  background-color: lightgray;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

/* Revealed cell */
.cell.revealed {
  background-color: lightblue;
  cursor: default;
}

/* Mine cell */
.cell.mine {
  color: white;
}

.cell.fatal-mine {
  background-color: red;
}

/* Flagged cell */
.cell.flagged {
  background-color: orange;
  color: white;
}

/* Wrong Flag */
.wrong-flag::after {
  content: "âœ•";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: blue;
  font-size: 20px;
}

/* Hint cell */
.hint {
  outline: 3px solid yellow;
  animation: pulse 0.4s infinite alternate;
}

@keyframes pulse {
  from {
    transform: scale(1);
  }
  to {
    transform: scale(1.1);
  }
}
  </style>
  </head>
  <body>
    <h1>SS</h1>

    <div id="grid">
      <!-- JS will generate rows and cells -->
    </div>

    <div>
      <p id="feedback"></p>
    </div>

    <div>
      <button id="hintBtn">Hint</button>
      <button id="resetBtn">Start a new game</button>
    </div>

    <script>
// ==== GLOBALs + CONSTANTS ====

let viewSize = 15;
let firstClick = true;
let board = new Map();
let grid = [];
let gameOver = false;
let cameraR = 0;
let cameraC = 0;
let startX = 0;
let startY = 0;
let touchMoved = false
let touchTimer = null
let isCameraMode = false

let dragAccumX = 0
let dragAccumY = 0 // so that not every small movement will cause camera to move


// ==== INITIALISATION + GENERATION ====

document.addEventListener("DOMContentLoaded", initialise);

function initialise() {
  document.getElementById("grid").innerHTML = "";
  generateGrid(viewSize);
  attachListeners();
  renderCamera();
}

// visible GRID
function generateGrid(size) {
let gridEl = document.getElementById("grid")
gridEl.innerHTML = ""

  for (let gridRow = 0; gridRow < size; gridRow++) {
    // let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < size; gridCol++) {
let cell = document.createElement("div")
cell.className = "cell"
cell.dataset.row = gridRow;
     cell.dataset.col = gridCol;
      gridEl.appendChild(cell)
    }}
   gridEl.style.setProperty("--grid-size", size)
}

// ==== GAME LOGIC ====
function revealCell(r, c) {
  ensureCell(r, c);
  // ensureNeighbours(r, c);
  let cell = getCell(r, c);
  if (cell.revealed || cell.flagged) return;

  // if clicked cell is mine
  // if (cell.mine == true) {
  //   gameOver = true;

  //   cellEl.classList.add("fatal-mine");
  //   cellEl.textContent = "ðŸ’£";

  //   revealAllMines();
  //   return;
  // }

  // Rule 1: revealed cell is always safe
  if (cell.mine == null) {
    cell.mine = false;
    cell.generated = true;
  }

  cell.revealed = true;
  //cellEl.classList.add("revealed");

  if (!firstClick) {
    resolveEntropy(cell);
  }

  cell.adjacent = computeAdjacent(r, c);
  propagateFrom(r, c);

  firstClick = false;

  // if (cell.adjacent > 0) return;

  if (cell.adjacent == 0) {
    for (let [nr, nc] of cell.neighbours) {
      // let n = getCell(nr, nc);
      // if (!n.revealed && n.adjacent === 0) {
      revealCell(nr, nc);
    }

    // for (let [nr, nc] of cell.neighbours) {
    //   let neighbourCell = document.getElementById(`cell-${nr}-${nc}`);
    //   revealCell(nr, nc, neighbourCell); // CASCADE!!
    // }
  }
}

function toggleFlag(sr, sc) {
//  e.preventDefault();
//  if (gameOver) return;
let wr = cameraR + sr
let wc = cameraC + sc

let cell = getCell(wr, wc)
  if (cell.revealed) return;

  cell.flagged = !cell.flagged;
renderCamera()
}

// function revealAllMines() {
//   for (let cell of board.values()) {
//     if (cell.mine == true) {
//       let el = document.getElementById(`${cell.r}-${cell.c}`);
//       if (!el) continue;

//       el.textContent = "ðŸ’£";
//       el.classList.add("mine");
//     }
//   }
// }

 function chordCell(r, c) {
   let cell = getCell(r, c);

   if (!cell.revealed || cell.adjacent == 0 || cell.adjacent == null) return;
 
  let flagged = 0;
  let hidden = [];

   for (let [nr, nc] of cell.neighbours) {
let n = getCell(nr, nc)

     if (n.flagged) flagged++;
     else if (!n.revealed) hidden.push([nr, nc]);
  }
   if (flagged == cell.adjacent) {
     hidden.forEach(([nr, nc]) => {
     revealCell(nr, nc);
     }); }
   }


function resetGame() {
  document.getElementById("feedback").textContent = "";
  board.clear();
  document.getElementById("grid").innerHTML = "";
  generateGrid(viewSize);
  firstClick = true;
  gameOver = false;
  attachListeners();
}


// ==== HINT SYSTEM ====
function revealHint() {
  let move = findGuaranteedMove();
  if (!move) {
    document.getElementById("feedback").textContent =
      "No guaranteed safe move.";
    return;
  }
  highlightCell(move.r, move.c);
}

function findGuaranteedMove() {
  for (let r = 0; r < viewSize; r++) {
    for (let c = 0; c < viewSize; c++) {
      let cell = getCell(r, c);

      if (!cell.revealed || cell.adjacent == 0) continue;

      let hidden = [];
      let flagged = 0;

      for (let [nr, nc] of cell.neighbours) {
        let n = getCell(nr, nc);
        if (n.flagged) flagged++;
        else if (!n.revealed) hidden.push([nr, nc]);
      }

      if (hidden.length == 0) continue;

      // guaranteed safe
      if (flagged == cell.adjacent) {
        return {
          r: hidden[0][0],
          c: hidden[0][1],
          type: "safe",
        };
      }

      // guaranteed mine
      if (flagged + hidden.length == cell.adjacent) {
        return {
          r: hidden[0][0],
          c: hidden[0][1],
          type: "mine",
        };
      }
    }
  }
  return null; // no forced move
}

function getNeighbourCoords(r, c) {
  let neighbours = [];

  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr == 0 && dc == 0) continue;

      neighbours.push([r + dr, c + dc]);
    }
  }
  return neighbours;
}

function highlightCell(r, c) {
  let cellElement = document.getElementById(`cell-${r}-${c}`);
  cellElement.classList.add("hint");

  // Remove highlight after short delay
  setTimeout(() => {
    cellElement.classList.remove("hint");
  }, 1500);
}

// ==== UI + INTERACTION ====

// function disableInputs() {
//   let cells = document.querySelectorAll("td");
//   cells.forEach((cell) => {
//     cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
//   });
// }

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll(".cell");

// Left click
  cells.forEach((cell) => {
    cell.addEventListener("click", onClick); 
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    resetGame();
  });

  document.getElementById("hintBtn").addEventListener("click", () => {
    revealHint();
  });

// Right click
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", (e) => {
e.preventDefault()
let sr = parseInt(cell.dataset.row)
let sc = parseInt(cell.dataset.col)

toggleFlag(sr, sc); 
  });
})




// Grid movement (for mobile camera)
let grid = document.getElementById("grid")

// touchstart
grid.addEventListener("touchstart", (e) => {
if (e.touches.length == 2) {
// camera mode
isCameraMode = true
touchMoved = false

startX = e.touches[0].clientX
startY = e.touches[0].clientY

return
}

if (e.touches.length == 1) {
isCameraMode = false
touchMoved = false

let touch = e.touches[0]
startX = touch.clientX
startY = touch.clientY

// long press = flag
touchTimer = setTimeout(() => {
let cell = getCellFromScreen(touch.clientX, touch.clientY)
if (cell) {
toggleFlag(cell.r, cell.c)
}}, 450)
}},
{ passive: false }
)

// touchmove
grid.addEventListener("touchmove", (e) => {
touchMoved = true

if (touchTimer) {
clearTimeout(touchTimer)
touchTimer = null
}

// Only 2 fingers move camera
if (isCameraMode && e.touches.length == 2) {
let dx = e.touches[0].clientX - startX
let dy = e.touches[0].clientY - startY

moveCamera(dx, dy)

startX = e.touches[0].clientX
startY = e.touches[0].clientY
}

e.preventDefault()
}, 
{ passive: false }
)

// touchend
grid.addEventListener("touchend", (e) => {
if (touchTimer) {
clearTimeout(touchTimer)
touchTimer = null
}

// single tap --> reveal
if (!touchMoved && !isCameraMode) {
let touch = e.changedTouches[0]
let cell = getCellFromScreen(touch.clientX, touch.clientY)

if (cell) {
revealCell(cell.r, cell.c)
}}
isCameraMode = false
},
{ passive: false }
)



// Camera movement
  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp" || e.key === "w") cameraR--;
    if (e.key === "ArrowDown" || e.key === "s") cameraR++;
    if (e.key === "ArrowLeft" || e.key === "a") cameraC--;
    if (e.key === "ArrowRight" || e.key === "d") cameraC++;

    renderCamera();
  });
}

function onClick(e) {
  let sr = parseInt(e.target.dataset.row);
  let sc = parseInt(e.target.dataset.col);

  let wr = cameraR + sr;
  let wc = cameraC + sc;
let cell = getCell(wr, wc)
if (cell.revealed) {
chordCell(wr, wc)
} else {
  revealCell(wr, wc);
}
  renderCamera();
}


function getCellFromScreen(x, y) {
let el = document.getElementFromPoint(x, y)
if (!el || !el.classList.contains("cell")) return null

let sr = parseInt(el.dataset.row)
let sc = parseInt(el.dataset.col)
let wr = cameraR + sr
let wc = cameraC + sc

return getCell(wr, wc)
}


// ==== BOARD VALIDATION ====

// function cloneBoard(board) {
//   let testBoard = [];
//   for (let row = 0; row < size; row++) {
//     let rowTest = [];
//     for (let col = 0; col < size; col++) {
//       rowTest.push({ ...getCell(row, col) });
//     }
//     testBoard.push(rowTest);
//   }
//   return testBoard; // only by returning, we can access it in the validate board (). it's not really global though
// }

// function cascadeReveal(clickedRow, clickedCol, testBoard, revealedMap) {
//   if (revealedMap[clickedRow][clickedCol]) return;
//   revealedMap[clickedRow][clickedCol] = true;
//   if (testBoard[clickedRow][clickedCol].adjacent > 0) return;
//   for (let [nr, nc] of testBoard[clickedRow][clickedCol].neighbours) {
//     cascadeReveal(nr, nc, testBoard, revealedMap); // CASCADE!!
//   }
// }

// ==== INFINITY ====

function key(r, c) {
  return `${r},${c}`;
}

function getCell(r, c) {
  ensureCell(r, c);
  return board.get(key(r, c));
}

function ensureCell(r, c) {
  let k = key(r, c);
  if (!board.has(k)) {
    board.set(k, createEmptyCell(r, c));
  }
}

function ensureNeighbours(r, c) {
  for (let [nr, nc] of getNeighbourCoords(r, c)) {
    ensureCell(nr, nc);
  }
}

function createEmptyCell(r, c) {
  return {
    r,
    c,
    mine: null, // null/true/false
    revealed: false,
    // number: null,
    adjacent: null,
    flagged: false,
    neighbours: getNeighbourCoords(r, c),

    committed: false, // mine is final
    generated: false, // whether mine has been decided
  };
}

function countNeighbourState(r, c) {
  let mines = 0;
  let undecided = 0;

  for (let [nr, nc] of getNeighbourCoords(r, c)) {
    let n = getCell(nr, nc);
    if (!n) continue;

    if (n.mine == true) mines++;
    else if (n.mine == null) undecided++;
  }
  return { mines, undecided };
}

function decideCell(r, c) {
  ensureCell(r, c);
  let cell = getCell(r, c);

  if (cell.generated) return cell.mine;

  // check constraints from neighbours
  for (let [nr, nc] of cell.neighbours) {
    let neighbour = getCell(nr, nc);
    if (!neighbour) continue;
    if (!neighbour.revealed) continue;
    if (neighbour.adjacent == null) continue;

    let { mines, undecided } = countNeighbourState(nr, nc);
    let remaining = neighbour.adjacent - mines;

    // if all remaining must be mines --> forced mine
    if (remaining == undecided && undecided > 0) {
      cell.mine = true;
      cell.generated = true;
      // cell.committed = true
      return true;
    }
  }

  // otherwise stay undecided
  // cell.mine = Math.random() < 0.15 // adjustable density
  // cell.generated = true
  // cell.committed = true
  return null;
}

function computeAdjacent(r, c) {
  // can check and commit. CANNOT CHANGE numbers
  let cell = getCell(r, c);
  let count = 0;

  for (let [nr, nc] of cell.neighbours) {
    let n = getCell(nr, nc);

    // ðŸ”¥ force decision if still unknown
    if (n.mine === null) {
      decideCell(nr, nc);
    }

    if (n.mine == true) count++;
  }

  cell.adjacent = count;
  return count;
}

function propagateFrom(r, c) {
  let cell = getCell(r, c);
  if (!cell.revealed) return;
  if (cell.adjacent == null) return;

  let mines = 0;
  let undecided = [];

  for (let [nr, nc] of cell.neighbours) {
    let n = getCell(nr, nc);
    if (!n) continue;

    if (n.mine == true) mines++;
    else if (n.mine == null) undecided.push(n);
  }
  let remaining = cell.adjacent - mines;
  if (remaining < 0) return;

  // Rule 1: all remaining are mines
  if (remaining == undecided.length && remaining > 0) {
    undecided.forEach((n) => {
      n.mine = true;
      n.generated = true;
      n.committed = true;
      propagateFrom(n.r, n.c);
    });
  }

  // Rule 2: all remaining safe
  if (remaining == 0 && undecided.length > 0) {
    undecided.forEach((n) => {
      n.mine = false;
      n.generated = true;
      n.committed = true;
      propagateFrom(n.r, n.c);
    });
  }
}

function resolveEntropy(cell) {
  let undecided = cell.neighbours
    .map(([r, c]) => getCell(r, c))
    .filter((n) => n.mine === null);

  if (undecided.length === 0) return;

  // probability scales with openness
  let chance =
    undecided.length >= 6 ? 0.15 : undecided.length >= 4 ? 0.2 : 0.25;

  if (Math.random() < chance) {
    let pick = undecided[Math.floor(Math.random() * undecided.length)];
    pick.mine = true;
    pick.generated = true;
    pick.committed = true;
  }
}

// ==== CAMERA VIEW ====
// function viewToWorld(r, c) {
//   return {
//     r: viewRow + r,
//     C: viewCol + c,
//   };
// }

// function renderView() {
//   // view changes when camera moves
//   for (let vr = 0; vr < size; vr++) {
//     for (let vc = 0; vc < size; vc++) {
//       let el = document.getElementById(`cell-${vr}-${vc}`);
//       let { r, c } = viewToWorld(vr, vc);
//       let cell = getCell(r, c);

//       el.className = "cell"; // reset visuals
//       el.textContent = "";

//       if (cell.revealed) {
//         el.classList.add("revealed");
//       }

//       if (cell.mine == true) {
//         el.textContent = "ðŸ’£";
//       } else if (cell.adjacent > 0) {
//         el.textContent = cell.adjacent;
//       }

//       if (cell.flagged) {
//         el.textContent = "ðŸš©";
//       }
//     }
//   }
// }

function renderCamera() {
  for (let sr = 0; sr < viewSize; sr++) {
    for (let sc = 0; sc < viewSize; sc++) {
      let wr = cameraR + sr;
      let wc = cameraC + sc;

      ensureCell(wr, wc);

      let cell = getCell(wr, wc); // board uses wr/wc
      let el = document.querySelector(`.cell[data-row="${sr}"][data-col="${sc}"]`) // dOM is sr/sc

if (!el) continue
      drawCell(el, cell);
    }
  }
}

function drawCell(el, cell) {
  el.className = "cell";
  el.textContent = "";

  if (cell.revealed) {
    el.classList.add("revealed");

    if (cell.mine) {
      el.textContent = "ðŸ’£";
    } else if (cell.adjacent > 0) {
      el.textContent = cell.adjacent;
    } else {
      el.textContent = "";
    }
  } else if (cell.flagged) {
    el.textContent = "ðŸš©";
  } else {
    el.textContent = "";
  }
}

function moveCamera(dx, dy) {
let cellSize = 30 // (set in css)

dragAccumX += dx
dragAccumY += dy

let moveX = Math.trunc(dragAccumX / cellSize)
let moveY = Math.trunc(dragAccumY / cellSize)

if (moveX != 0) {
cameraC -= moveX
dragAccumX -= moveX * cellSize
}

if (moveY != 0) {
cameraR -= moveY
dragAccumY -= moveY * cellSize
}

if (moveX != 0 || moveY != 0) {
renderCamera()
}
}

// ==== PREVENT BREAKAGE ====
function assertNeverIndexBoard() {
  throw new Error("do not index board[r][c]. Use getCell()");
}

board[0] = assertNeverIndexBoard;



    </script>
  </body>
</html>
