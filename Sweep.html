<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SS</title>

  <style>
/* Container for the grid */
#grid {
  display: grid;
  border-collapse: collapse;
  border-spacing: 0;
  grid-template-columns: repeat(var(--grid-size), 1fr); /* dynamic columns */
  width: fit-content;
  margin: 20px auto;
}

/* Each cell */
.cell {
  width: 30px;
  height: 30px;
  background-color: lightgray;
  border: 1px solid #999;
  padding: 0;
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  line-height: 30px;
  cursor: pointer;
  user-select: none;
}

/* Revealed cell */
.cell.revealed {
  background-color: lightblue;
  cursor: default;
}

/* Mine cell */
.cell.mine {
  background-color: red;
  color: white;
}

/* Flagged cell */
.cell.flagged {
  background-color: orange;
  color: white;
}


</style>

</head>
<body>

<h1>SS</h1>



<table id="grid">
  <!-- JS will generate rows and cells -->
</table>


<div> 
  <p id="feedback"></p>
</div>

<div> 
  <button id="resetBtn">Start a new game</button>
</div>

<label>Grid size:
<input type="number" id="gridSizeInput" value="10" min="5" max="20">
</label>
<label>Mines:
  <input type="number" id="mineInput" value="10" min="1" max="100">
</label>
<button id="applyBtn">Apply</button>



<script>

let gridSize = 10; // start with 10, easier to adjust later
let totalMines = 10;
let firstClick = true;
let board = [];
let grid = [];

// starting new game/setup
document.addEventListener("DOMContentLoaded", function () {
  generateGrid();
  generateBoard();
  attachListeners();
});

// visible GRID
function generateGrid() {
  grid = [];
  for (let gridRow = 0; gridRow < gridSize; gridRow++) {
    let tr = document.createElement("tr");
    for (let gridCol = 0; gridCol < gridSize; gridCol++) {
      let td = document.createElement("td");
      td.classList.add("cell");
      td.dataset.row = gridRow;
      td.dataset.col = gridCol;
      td.id = `cell-${gridRow}-${gridCol}`;
      tr.appendChild(td);
    }
    document.getElementById("grid").appendChild(tr);
  }
}

// create clear logic BOARD (the invisible one BTS)
function generateBoard(gridSize) {
  board = [];
  for (let row = 0; row < gridSize; row++) {
    rowData = [];
    for (let col = 0; col < gridSize; col++) {
      rowData.push({
        mine: false,
        revealed: false,
        adjacent: 0,
        flagged: false,
        safeZone: false,
      });
    }
    board.push(rowData);
  }
}

// create the MINES. put within checkanswer
function generateMines(clickedRow, clickedCol, newMines = totalMines) {
  totalMines = newMines
  let minesNumber = 0;
  let mineCol = 0;
  let mineRow = 0;

  while (minesNumber < totalMines) {
    mineCol = Math.floor(Math.random() * gridSize);
    mineRow = Math.floor(Math.random() * gridSize);
    if (mineCol == clickedCol && mineRow == clickedRow) continue;
    if (
      board[mineRow][mineCol].mine == true ||
      board[mineRow][mineCol].safeZone == true
    )
      continue;

    board[mineRow][mineCol].mine = true; // set the mine flag
    minesNumber++;
  }

  // count adjacent once all mines placed
  let boardCol = 0;
  let boardRow = 0;

  for (boardRow = 0; boardRow < gridSize; boardRow++) {
    for (boardCol = 0; boardCol < gridSize; boardCol++) {
      // For each cell, loop through its 8 neighbors
      // If neighbor is in bounds and has a mine, increment adjacent count

      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr == 0 && dc == 0) continue;

          let neighbourRow = boardRow + dr;
          let neighbourCol = boardCol + dc;
          if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
          if (neighbourCol < 0 || neighbourCol >= gridSize) continue;

          if (board[neighbourRow][neighbourCol].mine == true) {
            board[boardRow][boardCol].adjacent++;
          }
        }
      }
    }
  }
}

function checkAnswer(e) {
  let clickedCell = e.target;
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);

  if (firstClick) {
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        let neighbourRow = clickedRow + dr;
        let neighbourCol = clickedCol + dc;

        // ðŸ§± Check that the neighbor is still within the grid
        if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
        if (neighbourCol < 0 || neighbourCol >= gridSize) continue;

        board[neighbourRow][neighbourCol].safeZone = true;
      }
    }
    generateMines(clickedRow, clickedCol);
    firstClick = false;
    revealCell(clickedRow, clickedCol, clickedCell);
  } else {
    revealCell(clickedRow, clickedCol, clickedCell);
    checkWin();
  }
}

function revealCell(clickedRow, clickedCol, clickedCell) {
  if (
    board[clickedRow][clickedCol].revealed == true ||
    board[clickedRow][clickedCol].flagged == true
  ) {
    return;
  } else if (board[clickedRow][clickedCol].mine == true) {
    clickedCell.classList.add("mine");
    gameOver();
    return; // need this cuz after running gameOver(), it will come back to this
  } else {
    board[clickedRow][clickedCol].revealed = true;
    if (board[clickedRow][clickedCol].adjacent > 0) {
      clickedCell.classList.add("revealed");
      clickedCell.innerHTML = `${board[clickedRow][clickedCol].adjacent}`;
    } else {
      clickedCell.classList.add("revealed"); // the clicked cell only

      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr == 0 && dc == 0) continue;

          let neighbourRow = clickedRow + dr;
          let neighbourCol = clickedCol + dc;
          if (neighbourRow < 0 || neighbourRow >= gridSize) continue;
          if (neighbourCol < 0 || neighbourCol >= gridSize) continue;

          let neighbourCell = document.getElementById(
            `cell-${neighbourRow}-${neighbourCol}`
          );
          if (board[neighbourRow][neighbourCol].flagged == true) continue;
          revealCell(neighbourRow, neighbourCol, neighbourCell); // CASCADE!!
        }
      }
    }
  }
}

function toggleFlag(e) {
  let clickedCell = e.target;
  e.preventDefault();
  let clickedRow = parseInt(clickedCell.dataset.row);
  let clickedCol = parseInt(clickedCell.dataset.col);
  if (board[clickedRow][clickedCol].revealed == true) {
    return;
  } else if (board[clickedRow][clickedCol].flagged) {
    board[clickedRow][clickedCol].flagged = false;
    clickedCell.textContent = ""; // no flag
    clickedCell.classList.remove("flagged");
  } else {
    board[clickedRow][clickedCol].flagged = true;
    clickedCell.textContent = "ðŸš©"; // add flag
    clickedCell.classList.add("flagged");
  }
}

function gameOver() {
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      let cellData = board[r][c];
      let cellElement = document.getElementById(`cell-${r}-${c}`);

      if (cellData.mine) {
        cellData.revealed = true;
        cellElement.classList.add("mine");
        cellElement.textContent = "ðŸ’£"; // add flag
      }
      disableInputs();
    }
  }
}

function resetGame(newSize = gridSize, newMines = totalMines) {
gridSize = newSize
totalMines = newMines
  document.getElementById("feedback").textContent = "";
  board = [];
  generateBoard(gridSize);

  document.getElementById("grid").innerHTML = "";
  generateGrid();

  firstClick = true;

  attachListeners();
}

function checkWin() {
  let revealedCount = 0;
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      let cellData = board[r][c];
      if (!cellData.mine && cellData.revealed == true) {
        // just check non mines in case.
        revealedCount++;
      }
    }
  }

  if (revealedCount == gridSize * gridSize - totalMines) {
    disableInputs();
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        let cellData = board[r][c];
        if (cellData.mine == true && !cellData.revealed) {
          let cellElement = document.getElementById(`cell-${r}-${c}`);
          cellElement.textContent = "ðŸ’£"; // add flag
        }
        cellData.revealed = true;
        document.getElementById("feedback").textContent = "You win!";
      }
    }
  }
}

function disableInputs() {
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.replaceWith(cell.cloneNode(true)); // easiest way to remove all listeners
  });
}

function attachListeners() {
  // all my listeners
  let cells = document.querySelectorAll("td");
  cells.forEach((cell) => {
    cell.addEventListener("click", checkAnswer); // left click
  });
  cells.forEach((cell) => {
    cell.addEventListener("contextmenu", toggleFlag); // right click
  });
  document.getElementById("resetBtn").addEventListener("click", resetGame);
  document.getElementById("applyBtn").addEventListener("click", customise);

  // phone long tap
  cells.forEach((cell) => {
  let pressTimer;
  let longPressTriggered = false;

  cell.addEventListener("touchstart", (e) => {
    e.preventDefault();
    longPressTriggered = false;
    pressTimer = setTimeout(() => {
      toggleFlag(e);
      longPressTriggered = true;
    }, 600); // long press
  });

  cell.addEventListener("touchend", (e) => {
    clearTimeout(pressTimer);
    if (!longPressTriggered) {
      checkAnswer(e); // treat as single tap
    }
  });

  });
}

function customise() {
let inputSize = document.getElementById("gridSizeInput").value
let inputMine = document.getElementById("mineInput").value

let newSize = gridSize;
let newMines = totalMines;

if (inputSize !== "") {
newSize = parseInt(inputSize)
}
if (inputMine !== "") {
newMines = parseInt(inputMine)
}
resetGame(newSize, newMines)
}




</script>

</body>
</html>
